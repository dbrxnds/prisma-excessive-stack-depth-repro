
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.0.0
 * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
 */
export const prismaVersion: PrismaVersion = {
  client: "7.0.0",
  engine: "0c19ccc313cf9911a90d99d2ac2eb0280c76c513"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  Profile: 'Profile',
  Address: 'Address',
  UserSettings: 'UserSettings',
  UserSession: 'UserSession',
  Role: 'Role',
  UserRole: 'UserRole',
  Permission: 'Permission',
  RolePermission: 'RolePermission',
  Post: 'Post',
  Comment: 'Comment',
  Like: 'Like',
  Tag: 'Tag',
  PostTag: 'PostTag',
  Category: 'Category',
  PostCategory: 'PostCategory',
  PostRevision: 'PostRevision',
  PostView: 'PostView',
  Media: 'Media',
  PostMedia: 'PostMedia',
  Follow: 'Follow',
  Notification: 'Notification',
  Conversation: 'Conversation',
  ConversationParticipant: 'ConversationParticipant',
  Message: 'Message',
  Product: 'Product',
  ProductCategory: 'ProductCategory',
  ProductTag: 'ProductTag',
  ProductMedia: 'ProductMedia',
  ProductVariant: 'ProductVariant',
  Cart: 'Cart',
  CartItem: 'CartItem',
  Order: 'Order',
  OrderItem: 'OrderItem',
  Payment: 'Payment',
  Shipment: 'Shipment',
  Organization: 'Organization',
  OrganizationMember: 'OrganizationMember',
  Team: 'Team',
  TeamMember: 'TeamMember',
  Invitation: 'Invitation',
  Project: 'Project',
  ProjectTeam: 'ProjectTeam',
  Task: 'Task',
  Activity: 'Activity',
  AuditLog: 'AuditLog',
  Bookmark: 'Bookmark',
  Favorite: 'Favorite',
  Rating: 'Rating',
  Review: 'Review',
  Report: 'Report',
  Flag: 'Flag',
  Subscription: 'Subscription',
  SupportTicket: 'SupportTicket',
  TicketResponse: 'TicketResponse',
  TicketAttachment: 'TicketAttachment',
  Course: 'Course',
  CourseInstructor: 'CourseInstructor',
  Instructor: 'Instructor',
  CourseCategory: 'CourseCategory',
  CourseModule: 'CourseModule',
  Lesson: 'Lesson',
  Enrollment: 'Enrollment',
  Student: 'Student',
  LessonProgress: 'LessonProgress',
  Assignment: 'Assignment',
  AssignmentSubmission: 'AssignmentSubmission',
  Quiz: 'Quiz',
  QuizQuestion: 'QuizQuestion',
  QuizOption: 'QuizOption',
  QuizAttempt: 'QuizAttempt',
  QuizAnswer: 'QuizAnswer',
  Certificate: 'Certificate',
  CourseReview: 'CourseReview',
  Event: 'Event',
  Venue: 'Venue',
  EventTicket: 'EventTicket',
  EventRegistration: 'EventRegistration',
  Attendee: 'Attendee',
  EventSession: 'EventSession',
  Speaker: 'Speaker',
  EventSpeaker: 'EventSpeaker',
  SessionSpeaker: 'SessionSpeaker',
  Sponsor: 'Sponsor',
  EventSponsor: 'EventSponsor',
  Folder: 'Folder',
  File: 'File',
  FileVersion: 'FileVersion',
  FileShare: 'FileShare',
  FolderShare: 'FolderShare',
  FilePermission: 'FilePermission',
  FileDownload: 'FileDownload',
  PageView: 'PageView',
  AnalyticsSession: 'AnalyticsSession',
  AnalyticsEvent: 'AnalyticsEvent',
  ConversionGoal: 'ConversionGoal',
  Conversion: 'Conversion',
  ABTest: 'ABTest',
  ABTestVariant: 'ABTestVariant',
  ABTestAssignment: 'ABTestAssignment',
  Campaign: 'Campaign',
  CampaignEmail: 'CampaignEmail',
  EmailRecipient: 'EmailRecipient',
  Segment: 'Segment',
  CampaignSegment: 'CampaignSegment',
  SegmentSubscriber: 'SegmentSubscriber',
  Subscriber: 'Subscriber',
  Newsletter: 'Newsletter',
  NewsletterSubscriber: 'NewsletterSubscriber',
  NewsletterIssue: 'NewsletterIssue',
  LandingPage: 'LandingPage',
  Calendar: 'Calendar',
  Availability: 'Availability',
  Appointment: 'Appointment',
  TimeSlot: 'TimeSlot',
  Invoice: 'Invoice',
  Customer: 'Customer',
  InvoiceItem: 'InvoiceItem',
  InvoiceTransaction: 'InvoiceTransaction',
  Credit: 'Credit',
  Refund: 'Refund',
  ForumCategory: 'ForumCategory',
  ForumThread: 'ForumThread',
  ForumPost: 'ForumPost',
  Moderator: 'Moderator',
  ModeratorAction: 'ModeratorAction',
  Survey: 'Survey',
  SurveyQuestion: 'SurveyQuestion',
  SurveyQuestionOption: 'SurveyQuestionOption',
  SurveyResponse: 'SurveyResponse',
  SurveyAnswer: 'SurveyAnswer',
  Poll: 'Poll',
  PollOption: 'PollOption',
  PollVote: 'PollVote',
  Company: 'Company',
  Job: 'Job',
  JobApplication: 'JobApplication',
  Applicant: 'Applicant',
  Webhook: 'Webhook',
  WebhookDelivery: 'WebhookDelivery',
  APIKey: 'APIKey',
  APILog: 'APILog',
  Integration: 'Integration',
  IntegrationLog: 'IntegrationLog'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "profile" | "address" | "userSettings" | "userSession" | "role" | "userRole" | "permission" | "rolePermission" | "post" | "comment" | "like" | "tag" | "postTag" | "category" | "postCategory" | "postRevision" | "postView" | "media" | "postMedia" | "follow" | "notification" | "conversation" | "conversationParticipant" | "message" | "product" | "productCategory" | "productTag" | "productMedia" | "productVariant" | "cart" | "cartItem" | "order" | "orderItem" | "payment" | "shipment" | "organization" | "organizationMember" | "team" | "teamMember" | "invitation" | "project" | "projectTeam" | "task" | "activity" | "auditLog" | "bookmark" | "favorite" | "rating" | "review" | "report" | "flag" | "subscription" | "supportTicket" | "ticketResponse" | "ticketAttachment" | "course" | "courseInstructor" | "instructor" | "courseCategory" | "courseModule" | "lesson" | "enrollment" | "student" | "lessonProgress" | "assignment" | "assignmentSubmission" | "quiz" | "quizQuestion" | "quizOption" | "quizAttempt" | "quizAnswer" | "certificate" | "courseReview" | "event" | "venue" | "eventTicket" | "eventRegistration" | "attendee" | "eventSession" | "speaker" | "eventSpeaker" | "sessionSpeaker" | "sponsor" | "eventSponsor" | "folder" | "file" | "fileVersion" | "fileShare" | "folderShare" | "filePermission" | "fileDownload" | "pageView" | "analyticsSession" | "analyticsEvent" | "conversionGoal" | "conversion" | "aBTest" | "aBTestVariant" | "aBTestAssignment" | "campaign" | "campaignEmail" | "emailRecipient" | "segment" | "campaignSegment" | "segmentSubscriber" | "subscriber" | "newsletter" | "newsletterSubscriber" | "newsletterIssue" | "landingPage" | "calendar" | "availability" | "appointment" | "timeSlot" | "invoice" | "customer" | "invoiceItem" | "invoiceTransaction" | "credit" | "refund" | "forumCategory" | "forumThread" | "forumPost" | "moderator" | "moderatorAction" | "survey" | "surveyQuestion" | "surveyQuestionOption" | "surveyResponse" | "surveyAnswer" | "poll" | "pollOption" | "pollVote" | "company" | "job" | "jobApplication" | "applicant" | "webhook" | "webhookDelivery" | "aPIKey" | "aPILog" | "integration" | "integrationLog"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Profile: {
      payload: Prisma.$ProfilePayload<ExtArgs>
      fields: Prisma.ProfileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProfileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>
        }
        findFirst: {
          args: Prisma.ProfileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>
        }
        findMany: {
          args: Prisma.ProfileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]
        }
        create: {
          args: Prisma.ProfileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>
        }
        createMany: {
          args: Prisma.ProfileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]
        }
        delete: {
          args: Prisma.ProfileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>
        }
        update: {
          args: Prisma.ProfileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>
        }
        deleteMany: {
          args: Prisma.ProfileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProfileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]
        }
        upsert: {
          args: Prisma.ProfileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>
        }
        aggregate: {
          args: Prisma.ProfileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProfile>
        }
        groupBy: {
          args: Prisma.ProfileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProfileGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProfileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProfileCountAggregateOutputType> | number
        }
      }
    }
    Address: {
      payload: Prisma.$AddressPayload<ExtArgs>
      fields: Prisma.AddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        findFirst: {
          args: Prisma.AddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        findMany: {
          args: Prisma.AddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>[]
        }
        create: {
          args: Prisma.AddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        createMany: {
          args: Prisma.AddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>[]
        }
        delete: {
          args: Prisma.AddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        update: {
          args: Prisma.AddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        deleteMany: {
          args: Prisma.AddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>[]
        }
        upsert: {
          args: Prisma.AddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        aggregate: {
          args: Prisma.AddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAddress>
        }
        groupBy: {
          args: Prisma.AddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.AddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AddressCountAggregateOutputType> | number
        }
      }
    }
    UserSettings: {
      payload: Prisma.$UserSettingsPayload<ExtArgs>
      fields: Prisma.UserSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        findFirst: {
          args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        findMany: {
          args: Prisma.UserSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        create: {
          args: Prisma.UserSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        createMany: {
          args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        delete: {
          args: Prisma.UserSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        update: {
          args: Prisma.UserSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        deleteMany: {
          args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        upsert: {
          args: Prisma.UserSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        aggregate: {
          args: Prisma.UserSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSettings>
        }
        groupBy: {
          args: Prisma.UserSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSettingsCountAggregateOutputType> | number
        }
      }
    }
    UserSession: {
      payload: Prisma.$UserSessionPayload<ExtArgs>
      fields: Prisma.UserSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        findFirst: {
          args: Prisma.UserSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        findMany: {
          args: Prisma.UserSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
        }
        create: {
          args: Prisma.UserSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        createMany: {
          args: Prisma.UserSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
        }
        delete: {
          args: Prisma.UserSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        update: {
          args: Prisma.UserSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        deleteMany: {
          args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
        }
        upsert: {
          args: Prisma.UserSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        aggregate: {
          args: Prisma.UserSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSession>
        }
        groupBy: {
          args: Prisma.UserSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSessionCountAggregateOutputType> | number
        }
      }
    }
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>
      fields: Prisma.RoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    UserRole: {
      payload: Prisma.$UserRolePayload<ExtArgs>
      fields: Prisma.UserRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findFirst: {
          args: Prisma.UserRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findMany: {
          args: Prisma.UserRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        create: {
          args: Prisma.UserRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        createMany: {
          args: Prisma.UserRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        delete: {
          args: Prisma.UserRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        update: {
          args: Prisma.UserRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        deleteMany: {
          args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        upsert: {
          args: Prisma.UserRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        aggregate: {
          args: Prisma.UserRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRole>
        }
        groupBy: {
          args: Prisma.UserRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleCountAggregateOutputType> | number
        }
      }
    }
    Permission: {
      payload: Prisma.$PermissionPayload<ExtArgs>
      fields: Prisma.PermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findFirst: {
          args: Prisma.PermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findMany: {
          args: Prisma.PermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        create: {
          args: Prisma.PermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        createMany: {
          args: Prisma.PermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        delete: {
          args: Prisma.PermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        update: {
          args: Prisma.PermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        deleteMany: {
          args: Prisma.PermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        upsert: {
          args: Prisma.PermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        aggregate: {
          args: Prisma.PermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermission>
        }
        groupBy: {
          args: Prisma.PermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionCountAggregateOutputType> | number
        }
      }
    }
    RolePermission: {
      payload: Prisma.$RolePermissionPayload<ExtArgs>
      fields: Prisma.RolePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findFirst: {
          args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findMany: {
          args: Prisma.RolePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        create: {
          args: Prisma.RolePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        createMany: {
          args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        delete: {
          args: Prisma.RolePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        update: {
          args: Prisma.RolePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        deleteMany: {
          args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        upsert: {
          args: Prisma.RolePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        aggregate: {
          args: Prisma.RolePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRolePermission>
        }
        groupBy: {
          args: Prisma.RolePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RolePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionCountAggregateOutputType> | number
        }
      }
    }
    Post: {
      payload: Prisma.$PostPayload<ExtArgs>
      fields: Prisma.PostFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PostFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        findFirst: {
          args: Prisma.PostFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        findMany: {
          args: Prisma.PostFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[]
        }
        create: {
          args: Prisma.PostCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        createMany: {
          args: Prisma.PostCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[]
        }
        delete: {
          args: Prisma.PostDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        update: {
          args: Prisma.PostUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        deleteMany: {
          args: Prisma.PostDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PostUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[]
        }
        upsert: {
          args: Prisma.PostUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>
        }
        aggregate: {
          args: Prisma.PostAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePost>
        }
        groupBy: {
          args: Prisma.PostGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostGroupByOutputType>[]
        }
        count: {
          args: Prisma.PostCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostCountAggregateOutputType> | number
        }
      }
    }
    Comment: {
      payload: Prisma.$CommentPayload<ExtArgs>
      fields: Prisma.CommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
        }
      }
    }
    Like: {
      payload: Prisma.$LikePayload<ExtArgs>
      fields: Prisma.LikeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LikeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>
        }
        findFirst: {
          args: Prisma.LikeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>
        }
        findMany: {
          args: Prisma.LikeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>[]
        }
        create: {
          args: Prisma.LikeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>
        }
        createMany: {
          args: Prisma.LikeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>[]
        }
        delete: {
          args: Prisma.LikeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>
        }
        update: {
          args: Prisma.LikeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>
        }
        deleteMany: {
          args: Prisma.LikeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LikeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LikeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>[]
        }
        upsert: {
          args: Prisma.LikeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LikePayload>
        }
        aggregate: {
          args: Prisma.LikeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLike>
        }
        groupBy: {
          args: Prisma.LikeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LikeGroupByOutputType>[]
        }
        count: {
          args: Prisma.LikeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LikeCountAggregateOutputType> | number
        }
      }
    }
    Tag: {
      payload: Prisma.$TagPayload<ExtArgs>
      fields: Prisma.TagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findFirst: {
          args: Prisma.TagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findMany: {
          args: Prisma.TagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        create: {
          args: Prisma.TagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        createMany: {
          args: Prisma.TagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        delete: {
          args: Prisma.TagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        update: {
          args: Prisma.TagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        deleteMany: {
          args: Prisma.TagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        upsert: {
          args: Prisma.TagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        aggregate: {
          args: Prisma.TagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTag>
        }
        groupBy: {
          args: Prisma.TagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagGroupByOutputType>[]
        }
        count: {
          args: Prisma.TagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagCountAggregateOutputType> | number
        }
      }
    }
    PostTag: {
      payload: Prisma.$PostTagPayload<ExtArgs>
      fields: Prisma.PostTagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PostTagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PostTagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>
        }
        findFirst: {
          args: Prisma.PostTagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PostTagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>
        }
        findMany: {
          args: Prisma.PostTagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>[]
        }
        create: {
          args: Prisma.PostTagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>
        }
        createMany: {
          args: Prisma.PostTagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PostTagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>[]
        }
        delete: {
          args: Prisma.PostTagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>
        }
        update: {
          args: Prisma.PostTagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>
        }
        deleteMany: {
          args: Prisma.PostTagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PostTagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PostTagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>[]
        }
        upsert: {
          args: Prisma.PostTagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostTagPayload>
        }
        aggregate: {
          args: Prisma.PostTagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePostTag>
        }
        groupBy: {
          args: Prisma.PostTagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostTagGroupByOutputType>[]
        }
        count: {
          args: Prisma.PostTagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostTagCountAggregateOutputType> | number
        }
      }
    }
    Category: {
      payload: Prisma.$CategoryPayload<ExtArgs>
      fields: Prisma.CategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findFirst: {
          args: Prisma.CategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findMany: {
          args: Prisma.CategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        create: {
          args: Prisma.CategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        createMany: {
          args: Prisma.CategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        delete: {
          args: Prisma.CategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        update: {
          args: Prisma.CategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        deleteMany: {
          args: Prisma.CategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        upsert: {
          args: Prisma.CategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        aggregate: {
          args: Prisma.CategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategory>
        }
        groupBy: {
          args: Prisma.CategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryCountAggregateOutputType> | number
        }
      }
    }
    PostCategory: {
      payload: Prisma.$PostCategoryPayload<ExtArgs>
      fields: Prisma.PostCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PostCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PostCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>
        }
        findFirst: {
          args: Prisma.PostCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PostCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>
        }
        findMany: {
          args: Prisma.PostCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
        }
        create: {
          args: Prisma.PostCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>
        }
        createMany: {
          args: Prisma.PostCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PostCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
        }
        delete: {
          args: Prisma.PostCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>
        }
        update: {
          args: Prisma.PostCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>
        }
        deleteMany: {
          args: Prisma.PostCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PostCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PostCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
        }
        upsert: {
          args: Prisma.PostCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostCategoryPayload>
        }
        aggregate: {
          args: Prisma.PostCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePostCategory>
        }
        groupBy: {
          args: Prisma.PostCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PostCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostCategoryCountAggregateOutputType> | number
        }
      }
    }
    PostRevision: {
      payload: Prisma.$PostRevisionPayload<ExtArgs>
      fields: Prisma.PostRevisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PostRevisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PostRevisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>
        }
        findFirst: {
          args: Prisma.PostRevisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PostRevisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>
        }
        findMany: {
          args: Prisma.PostRevisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>[]
        }
        create: {
          args: Prisma.PostRevisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>
        }
        createMany: {
          args: Prisma.PostRevisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PostRevisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>[]
        }
        delete: {
          args: Prisma.PostRevisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>
        }
        update: {
          args: Prisma.PostRevisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>
        }
        deleteMany: {
          args: Prisma.PostRevisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PostRevisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PostRevisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>[]
        }
        upsert: {
          args: Prisma.PostRevisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostRevisionPayload>
        }
        aggregate: {
          args: Prisma.PostRevisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePostRevision>
        }
        groupBy: {
          args: Prisma.PostRevisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostRevisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PostRevisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostRevisionCountAggregateOutputType> | number
        }
      }
    }
    PostView: {
      payload: Prisma.$PostViewPayload<ExtArgs>
      fields: Prisma.PostViewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PostViewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PostViewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>
        }
        findFirst: {
          args: Prisma.PostViewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PostViewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>
        }
        findMany: {
          args: Prisma.PostViewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>[]
        }
        create: {
          args: Prisma.PostViewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>
        }
        createMany: {
          args: Prisma.PostViewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PostViewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>[]
        }
        delete: {
          args: Prisma.PostViewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>
        }
        update: {
          args: Prisma.PostViewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>
        }
        deleteMany: {
          args: Prisma.PostViewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PostViewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PostViewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>[]
        }
        upsert: {
          args: Prisma.PostViewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostViewPayload>
        }
        aggregate: {
          args: Prisma.PostViewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePostView>
        }
        groupBy: {
          args: Prisma.PostViewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostViewGroupByOutputType>[]
        }
        count: {
          args: Prisma.PostViewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostViewCountAggregateOutputType> | number
        }
      }
    }
    Media: {
      payload: Prisma.$MediaPayload<ExtArgs>
      fields: Prisma.MediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        findFirst: {
          args: Prisma.MediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        findMany: {
          args: Prisma.MediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        create: {
          args: Prisma.MediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        createMany: {
          args: Prisma.MediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        delete: {
          args: Prisma.MediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        update: {
          args: Prisma.MediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        deleteMany: {
          args: Prisma.MediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        upsert: {
          args: Prisma.MediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        aggregate: {
          args: Prisma.MediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedia>
        }
        groupBy: {
          args: Prisma.MediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.MediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaCountAggregateOutputType> | number
        }
      }
    }
    PostMedia: {
      payload: Prisma.$PostMediaPayload<ExtArgs>
      fields: Prisma.PostMediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PostMediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PostMediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>
        }
        findFirst: {
          args: Prisma.PostMediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PostMediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>
        }
        findMany: {
          args: Prisma.PostMediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>[]
        }
        create: {
          args: Prisma.PostMediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>
        }
        createMany: {
          args: Prisma.PostMediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PostMediaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>[]
        }
        delete: {
          args: Prisma.PostMediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>
        }
        update: {
          args: Prisma.PostMediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>
        }
        deleteMany: {
          args: Prisma.PostMediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PostMediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PostMediaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>[]
        }
        upsert: {
          args: Prisma.PostMediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PostMediaPayload>
        }
        aggregate: {
          args: Prisma.PostMediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePostMedia>
        }
        groupBy: {
          args: Prisma.PostMediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostMediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.PostMediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PostMediaCountAggregateOutputType> | number
        }
      }
    }
    Follow: {
      payload: Prisma.$FollowPayload<ExtArgs>
      fields: Prisma.FollowFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FollowFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>
        }
        findFirst: {
          args: Prisma.FollowFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>
        }
        findMany: {
          args: Prisma.FollowFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>[]
        }
        create: {
          args: Prisma.FollowCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>
        }
        createMany: {
          args: Prisma.FollowCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>[]
        }
        delete: {
          args: Prisma.FollowDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>
        }
        update: {
          args: Prisma.FollowUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>
        }
        deleteMany: {
          args: Prisma.FollowDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FollowUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>[]
        }
        upsert: {
          args: Prisma.FollowUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FollowPayload>
        }
        aggregate: {
          args: Prisma.FollowAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFollow>
        }
        groupBy: {
          args: Prisma.FollowGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FollowGroupByOutputType>[]
        }
        count: {
          args: Prisma.FollowCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FollowCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    Conversation: {
      payload: Prisma.$ConversationPayload<ExtArgs>
      fields: Prisma.ConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findFirst: {
          args: Prisma.ConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findMany: {
          args: Prisma.ConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        create: {
          args: Prisma.ConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        createMany: {
          args: Prisma.ConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        delete: {
          args: Prisma.ConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        update: {
          args: Prisma.ConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        deleteMany: {
          args: Prisma.ConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        upsert: {
          args: Prisma.ConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        aggregate: {
          args: Prisma.ConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversation>
        }
        groupBy: {
          args: Prisma.ConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationCountAggregateOutputType> | number
        }
      }
    }
    ConversationParticipant: {
      payload: Prisma.$ConversationParticipantPayload<ExtArgs>
      fields: Prisma.ConversationParticipantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        findFirst: {
          args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        findMany: {
          args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
        }
        create: {
          args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        createMany: {
          args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
        }
        delete: {
          args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        update: {
          args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        deleteMany: {
          args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
        }
        upsert: {
          args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        aggregate: {
          args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversationParticipant>
        }
        groupBy: {
          args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationParticipantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationParticipantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationParticipantCountAggregateOutputType> | number
        }
      }
    }
    Message: {
      payload: Prisma.$MessagePayload<ExtArgs>
      fields: Prisma.MessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findFirst: {
          args: Prisma.MessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findMany: {
          args: Prisma.MessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        create: {
          args: Prisma.MessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        createMany: {
          args: Prisma.MessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        delete: {
          args: Prisma.MessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        update: {
          args: Prisma.MessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        deleteMany: {
          args: Prisma.MessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        upsert: {
          args: Prisma.MessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.MessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    Product: {
      payload: Prisma.$ProductPayload<ExtArgs>
      fields: Prisma.ProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findFirst: {
          args: Prisma.ProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findMany: {
          args: Prisma.ProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        create: {
          args: Prisma.ProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        createMany: {
          args: Prisma.ProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        delete: {
          args: Prisma.ProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        update: {
          args: Prisma.ProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        deleteMany: {
          args: Prisma.ProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        upsert: {
          args: Prisma.ProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        aggregate: {
          args: Prisma.ProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProduct>
        }
        groupBy: {
          args: Prisma.ProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCountAggregateOutputType> | number
        }
      }
    }
    ProductCategory: {
      payload: Prisma.$ProductCategoryPayload<ExtArgs>
      fields: Prisma.ProductCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        findFirst: {
          args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        findMany: {
          args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
        }
        create: {
          args: Prisma.ProductCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        createMany: {
          args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
        }
        delete: {
          args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        update: {
          args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        deleteMany: {
          args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
        }
        upsert: {
          args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
        }
        aggregate: {
          args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductCategory>
        }
        groupBy: {
          args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCategoryCountAggregateOutputType> | number
        }
      }
    }
    ProductTag: {
      payload: Prisma.$ProductTagPayload<ExtArgs>
      fields: Prisma.ProductTagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductTagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductTagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        findFirst: {
          args: Prisma.ProductTagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductTagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        findMany: {
          args: Prisma.ProductTagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
        }
        create: {
          args: Prisma.ProductTagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        createMany: {
          args: Prisma.ProductTagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductTagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
        }
        delete: {
          args: Prisma.ProductTagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        update: {
          args: Prisma.ProductTagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        deleteMany: {
          args: Prisma.ProductTagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductTagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductTagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
        }
        upsert: {
          args: Prisma.ProductTagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTagPayload>
        }
        aggregate: {
          args: Prisma.ProductTagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductTag>
        }
        groupBy: {
          args: Prisma.ProductTagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductTagGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductTagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductTagCountAggregateOutputType> | number
        }
      }
    }
    ProductMedia: {
      payload: Prisma.$ProductMediaPayload<ExtArgs>
      fields: Prisma.ProductMediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductMediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductMediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        findFirst: {
          args: Prisma.ProductMediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductMediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        findMany: {
          args: Prisma.ProductMediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
        }
        create: {
          args: Prisma.ProductMediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        createMany: {
          args: Prisma.ProductMediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductMediaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
        }
        delete: {
          args: Prisma.ProductMediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        update: {
          args: Prisma.ProductMediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        deleteMany: {
          args: Prisma.ProductMediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductMediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductMediaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
        }
        upsert: {
          args: Prisma.ProductMediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        aggregate: {
          args: Prisma.ProductMediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductMedia>
        }
        groupBy: {
          args: Prisma.ProductMediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductMediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductMediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductMediaCountAggregateOutputType> | number
        }
      }
    }
    ProductVariant: {
      payload: Prisma.$ProductVariantPayload<ExtArgs>
      fields: Prisma.ProductVariantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        findFirst: {
          args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        findMany: {
          args: Prisma.ProductVariantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
        }
        create: {
          args: Prisma.ProductVariantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        createMany: {
          args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
        }
        delete: {
          args: Prisma.ProductVariantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        update: {
          args: Prisma.ProductVariantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        deleteMany: {
          args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
        }
        upsert: {
          args: Prisma.ProductVariantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        aggregate: {
          args: Prisma.ProductVariantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductVariant>
        }
        groupBy: {
          args: Prisma.ProductVariantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductVariantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductVariantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductVariantCountAggregateOutputType> | number
        }
      }
    }
    Cart: {
      payload: Prisma.$CartPayload<ExtArgs>
      fields: Prisma.CartFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CartFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        findFirst: {
          args: Prisma.CartFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        findMany: {
          args: Prisma.CartFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>[]
        }
        create: {
          args: Prisma.CartCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        createMany: {
          args: Prisma.CartCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>[]
        }
        delete: {
          args: Prisma.CartDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        update: {
          args: Prisma.CartUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        deleteMany: {
          args: Prisma.CartDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CartUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>[]
        }
        upsert: {
          args: Prisma.CartUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        aggregate: {
          args: Prisma.CartAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCart>
        }
        groupBy: {
          args: Prisma.CartGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartGroupByOutputType>[]
        }
        count: {
          args: Prisma.CartCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartCountAggregateOutputType> | number
        }
      }
    }
    CartItem: {
      payload: Prisma.$CartItemPayload<ExtArgs>
      fields: Prisma.CartItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CartItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        findFirst: {
          args: Prisma.CartItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        findMany: {
          args: Prisma.CartItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>[]
        }
        create: {
          args: Prisma.CartItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        createMany: {
          args: Prisma.CartItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>[]
        }
        delete: {
          args: Prisma.CartItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        update: {
          args: Prisma.CartItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        deleteMany: {
          args: Prisma.CartItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CartItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>[]
        }
        upsert: {
          args: Prisma.CartItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        aggregate: {
          args: Prisma.CartItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCartItem>
        }
        groupBy: {
          args: Prisma.CartItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.CartItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartItemCountAggregateOutputType> | number
        }
      }
    }
    Order: {
      payload: Prisma.$OrderPayload<ExtArgs>
      fields: Prisma.OrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findFirst: {
          args: Prisma.OrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findMany: {
          args: Prisma.OrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        create: {
          args: Prisma.OrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        createMany: {
          args: Prisma.OrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        delete: {
          args: Prisma.OrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        update: {
          args: Prisma.OrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        deleteMany: {
          args: Prisma.OrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        upsert: {
          args: Prisma.OrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        aggregate: {
          args: Prisma.OrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrder>
        }
        groupBy: {
          args: Prisma.OrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderCountAggregateOutputType> | number
        }
      }
    }
    OrderItem: {
      payload: Prisma.$OrderItemPayload<ExtArgs>
      fields: Prisma.OrderItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        findFirst: {
          args: Prisma.OrderItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        findMany: {
          args: Prisma.OrderItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
        }
        create: {
          args: Prisma.OrderItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        createMany: {
          args: Prisma.OrderItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
        }
        delete: {
          args: Prisma.OrderItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        update: {
          args: Prisma.OrderItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        deleteMany: {
          args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
        }
        upsert: {
          args: Prisma.OrderItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        aggregate: {
          args: Prisma.OrderItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrderItem>
        }
        groupBy: {
          args: Prisma.OrderItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderItemCountAggregateOutputType> | number
        }
      }
    }
    Payment: {
      payload: Prisma.$PaymentPayload<ExtArgs>
      fields: Prisma.PaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findFirst: {
          args: Prisma.PaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findMany: {
          args: Prisma.PaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        create: {
          args: Prisma.PaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        createMany: {
          args: Prisma.PaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        delete: {
          args: Prisma.PaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        update: {
          args: Prisma.PaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        upsert: {
          args: Prisma.PaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        aggregate: {
          args: Prisma.PaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment>
        }
        groupBy: {
          args: Prisma.PaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentCountAggregateOutputType> | number
        }
      }
    }
    Shipment: {
      payload: Prisma.$ShipmentPayload<ExtArgs>
      fields: Prisma.ShipmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ShipmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ShipmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>
        }
        findFirst: {
          args: Prisma.ShipmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ShipmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>
        }
        findMany: {
          args: Prisma.ShipmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
        }
        create: {
          args: Prisma.ShipmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>
        }
        createMany: {
          args: Prisma.ShipmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ShipmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
        }
        delete: {
          args: Prisma.ShipmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>
        }
        update: {
          args: Prisma.ShipmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>
        }
        deleteMany: {
          args: Prisma.ShipmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ShipmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ShipmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
        }
        upsert: {
          args: Prisma.ShipmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShipmentPayload>
        }
        aggregate: {
          args: Prisma.ShipmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateShipment>
        }
        groupBy: {
          args: Prisma.ShipmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShipmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ShipmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShipmentCountAggregateOutputType> | number
        }
      }
    }
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>
      fields: Prisma.OrganizationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>
        }
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number
        }
      }
    }
    OrganizationMember: {
      payload: Prisma.$OrganizationMemberPayload<ExtArgs>
      fields: Prisma.OrganizationMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        findFirst: {
          args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        findMany: {
          args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
        }
        create: {
          args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        createMany: {
          args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
        }
        delete: {
          args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        update: {
          args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        aggregate: {
          args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationMember>
        }
        groupBy: {
          args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationMemberCountAggregateOutputType> | number
        }
      }
    }
    Team: {
      payload: Prisma.$TeamPayload<ExtArgs>
      fields: Prisma.TeamFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TeamFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        findFirst: {
          args: Prisma.TeamFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        findMany: {
          args: Prisma.TeamFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[]
        }
        create: {
          args: Prisma.TeamCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        createMany: {
          args: Prisma.TeamCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[]
        }
        delete: {
          args: Prisma.TeamDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        update: {
          args: Prisma.TeamUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        deleteMany: {
          args: Prisma.TeamDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TeamUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[]
        }
        upsert: {
          args: Prisma.TeamUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        aggregate: {
          args: Prisma.TeamAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeam>
        }
        groupBy: {
          args: Prisma.TeamGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TeamGroupByOutputType>[]
        }
        count: {
          args: Prisma.TeamCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TeamCountAggregateOutputType> | number
        }
      }
    }
    TeamMember: {
      payload: Prisma.$TeamMemberPayload<ExtArgs>
      fields: Prisma.TeamMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>
        }
        findFirst: {
          args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>
        }
        findMany: {
          args: Prisma.TeamMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
        }
        create: {
          args: Prisma.TeamMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>
        }
        createMany: {
          args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
        }
        delete: {
          args: Prisma.TeamMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>
        }
        update: {
          args: Prisma.TeamMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>
        }
        deleteMany: {
          args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
        }
        upsert: {
          args: Prisma.TeamMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>
        }
        aggregate: {
          args: Prisma.TeamMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeamMember>
        }
        groupBy: {
          args: Prisma.TeamMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TeamMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.TeamMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TeamMemberCountAggregateOutputType> | number
        }
      }
    }
    Invitation: {
      payload: Prisma.$InvitationPayload<ExtArgs>
      fields: Prisma.InvitationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvitationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        findFirst: {
          args: Prisma.InvitationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        findMany: {
          args: Prisma.InvitationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>[]
        }
        create: {
          args: Prisma.InvitationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        createMany: {
          args: Prisma.InvitationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>[]
        }
        delete: {
          args: Prisma.InvitationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        update: {
          args: Prisma.InvitationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        deleteMany: {
          args: Prisma.InvitationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvitationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>[]
        }
        upsert: {
          args: Prisma.InvitationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        aggregate: {
          args: Prisma.InvitationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvitation>
        }
        groupBy: {
          args: Prisma.InvitationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvitationGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvitationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvitationCountAggregateOutputType> | number
        }
      }
    }
    Project: {
      payload: Prisma.$ProjectPayload<ExtArgs>
      fields: Prisma.ProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findFirst: {
          args: Prisma.ProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findMany: {
          args: Prisma.ProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        create: {
          args: Prisma.ProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        createMany: {
          args: Prisma.ProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        delete: {
          args: Prisma.ProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        update: {
          args: Prisma.ProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        deleteMany: {
          args: Prisma.ProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        upsert: {
          args: Prisma.ProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        aggregate: {
          args: Prisma.ProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProject>
        }
        groupBy: {
          args: Prisma.ProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectCountAggregateOutputType> | number
        }
      }
    }
    ProjectTeam: {
      payload: Prisma.$ProjectTeamPayload<ExtArgs>
      fields: Prisma.ProjectTeamFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectTeamFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectTeamFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
        }
        findFirst: {
          args: Prisma.ProjectTeamFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectTeamFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
        }
        findMany: {
          args: Prisma.ProjectTeamFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>[]
        }
        create: {
          args: Prisma.ProjectTeamCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
        }
        createMany: {
          args: Prisma.ProjectTeamCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectTeamCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>[]
        }
        delete: {
          args: Prisma.ProjectTeamDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
        }
        update: {
          args: Prisma.ProjectTeamUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
        }
        deleteMany: {
          args: Prisma.ProjectTeamDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectTeamUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectTeamUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>[]
        }
        upsert: {
          args: Prisma.ProjectTeamUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
        }
        aggregate: {
          args: Prisma.ProjectTeamAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectTeam>
        }
        groupBy: {
          args: Prisma.ProjectTeamGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectTeamGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectTeamCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectTeamCountAggregateOutputType> | number
        }
      }
    }
    Task: {
      payload: Prisma.$TaskPayload<ExtArgs>
      fields: Prisma.TaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findFirst: {
          args: Prisma.TaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findMany: {
          args: Prisma.TaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        create: {
          args: Prisma.TaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        createMany: {
          args: Prisma.TaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        delete: {
          args: Prisma.TaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        update: {
          args: Prisma.TaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        deleteMany: {
          args: Prisma.TaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        upsert: {
          args: Prisma.TaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        aggregate: {
          args: Prisma.TaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTask>
        }
        groupBy: {
          args: Prisma.TaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskCountAggregateOutputType> | number
        }
      }
    }
    Activity: {
      payload: Prisma.$ActivityPayload<ExtArgs>
      fields: Prisma.ActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        findFirst: {
          args: Prisma.ActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        findMany: {
          args: Prisma.ActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[]
        }
        create: {
          args: Prisma.ActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        createMany: {
          args: Prisma.ActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[]
        }
        delete: {
          args: Prisma.ActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        update: {
          args: Prisma.ActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        deleteMany: {
          args: Prisma.ActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[]
        }
        upsert: {
          args: Prisma.ActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        aggregate: {
          args: Prisma.ActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActivity>
        }
        groupBy: {
          args: Prisma.ActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.ActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Bookmark: {
      payload: Prisma.$BookmarkPayload<ExtArgs>
      fields: Prisma.BookmarkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BookmarkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BookmarkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>
        }
        findFirst: {
          args: Prisma.BookmarkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BookmarkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>
        }
        findMany: {
          args: Prisma.BookmarkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
        }
        create: {
          args: Prisma.BookmarkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>
        }
        createMany: {
          args: Prisma.BookmarkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BookmarkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
        }
        delete: {
          args: Prisma.BookmarkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>
        }
        update: {
          args: Prisma.BookmarkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>
        }
        deleteMany: {
          args: Prisma.BookmarkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BookmarkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BookmarkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
        }
        upsert: {
          args: Prisma.BookmarkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookmarkPayload>
        }
        aggregate: {
          args: Prisma.BookmarkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBookmark>
        }
        groupBy: {
          args: Prisma.BookmarkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BookmarkGroupByOutputType>[]
        }
        count: {
          args: Prisma.BookmarkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BookmarkCountAggregateOutputType> | number
        }
      }
    }
    Favorite: {
      payload: Prisma.$FavoritePayload<ExtArgs>
      fields: Prisma.FavoriteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        findFirst: {
          args: Prisma.FavoriteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        findMany: {
          args: Prisma.FavoriteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>[]
        }
        create: {
          args: Prisma.FavoriteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        createMany: {
          args: Prisma.FavoriteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>[]
        }
        delete: {
          args: Prisma.FavoriteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        update: {
          args: Prisma.FavoriteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        deleteMany: {
          args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>[]
        }
        upsert: {
          args: Prisma.FavoriteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        aggregate: {
          args: Prisma.FavoriteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFavorite>
        }
        groupBy: {
          args: Prisma.FavoriteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FavoriteGroupByOutputType>[]
        }
        count: {
          args: Prisma.FavoriteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FavoriteCountAggregateOutputType> | number
        }
      }
    }
    Rating: {
      payload: Prisma.$RatingPayload<ExtArgs>
      fields: Prisma.RatingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RatingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>
        }
        findFirst: {
          args: Prisma.RatingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>
        }
        findMany: {
          args: Prisma.RatingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>[]
        }
        create: {
          args: Prisma.RatingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>
        }
        createMany: {
          args: Prisma.RatingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>[]
        }
        delete: {
          args: Prisma.RatingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>
        }
        update: {
          args: Prisma.RatingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>
        }
        deleteMany: {
          args: Prisma.RatingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RatingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>[]
        }
        upsert: {
          args: Prisma.RatingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>
        }
        aggregate: {
          args: Prisma.RatingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRating>
        }
        groupBy: {
          args: Prisma.RatingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RatingGroupByOutputType>[]
        }
        count: {
          args: Prisma.RatingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RatingCountAggregateOutputType> | number
        }
      }
    }
    Review: {
      payload: Prisma.$ReviewPayload<ExtArgs>
      fields: Prisma.ReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        findFirst: {
          args: Prisma.ReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        findMany: {
          args: Prisma.ReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        create: {
          args: Prisma.ReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        createMany: {
          args: Prisma.ReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        delete: {
          args: Prisma.ReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        update: {
          args: Prisma.ReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        deleteMany: {
          args: Prisma.ReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        upsert: {
          args: Prisma.ReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        aggregate: {
          args: Prisma.ReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReview>
        }
        groupBy: {
          args: Prisma.ReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReviewCountAggregateOutputType> | number
        }
      }
    }
    Report: {
      payload: Prisma.$ReportPayload<ExtArgs>
      fields: Prisma.ReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        findFirst: {
          args: Prisma.ReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        findMany: {
          args: Prisma.ReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        create: {
          args: Prisma.ReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        createMany: {
          args: Prisma.ReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        delete: {
          args: Prisma.ReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        update: {
          args: Prisma.ReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        deleteMany: {
          args: Prisma.ReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        upsert: {
          args: Prisma.ReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        aggregate: {
          args: Prisma.ReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReport>
        }
        groupBy: {
          args: Prisma.ReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportCountAggregateOutputType> | number
        }
      }
    }
    Flag: {
      payload: Prisma.$FlagPayload<ExtArgs>
      fields: Prisma.FlagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FlagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FlagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>
        }
        findFirst: {
          args: Prisma.FlagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FlagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>
        }
        findMany: {
          args: Prisma.FlagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>[]
        }
        create: {
          args: Prisma.FlagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>
        }
        createMany: {
          args: Prisma.FlagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FlagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>[]
        }
        delete: {
          args: Prisma.FlagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>
        }
        update: {
          args: Prisma.FlagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>
        }
        deleteMany: {
          args: Prisma.FlagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FlagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FlagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>[]
        }
        upsert: {
          args: Prisma.FlagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FlagPayload>
        }
        aggregate: {
          args: Prisma.FlagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFlag>
        }
        groupBy: {
          args: Prisma.FlagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FlagGroupByOutputType>[]
        }
        count: {
          args: Prisma.FlagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FlagCountAggregateOutputType> | number
        }
      }
    }
    Subscription: {
      payload: Prisma.$SubscriptionPayload<ExtArgs>
      fields: Prisma.SubscriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        findFirst: {
          args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        findMany: {
          args: Prisma.SubscriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
        }
        create: {
          args: Prisma.SubscriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        createMany: {
          args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
        }
        delete: {
          args: Prisma.SubscriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        update: {
          args: Prisma.SubscriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        deleteMany: {
          args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
        }
        upsert: {
          args: Prisma.SubscriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        aggregate: {
          args: Prisma.SubscriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscription>
        }
        groupBy: {
          args: Prisma.SubscriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubscriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionCountAggregateOutputType> | number
        }
      }
    }
    SupportTicket: {
      payload: Prisma.$SupportTicketPayload<ExtArgs>
      fields: Prisma.SupportTicketFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        findFirst: {
          args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        findMany: {
          args: Prisma.SupportTicketFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
        }
        create: {
          args: Prisma.SupportTicketCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        createMany: {
          args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
        }
        delete: {
          args: Prisma.SupportTicketDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        update: {
          args: Prisma.SupportTicketUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        deleteMany: {
          args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
        }
        upsert: {
          args: Prisma.SupportTicketUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        aggregate: {
          args: Prisma.SupportTicketAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupportTicket>
        }
        groupBy: {
          args: Prisma.SupportTicketGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupportTicketGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupportTicketCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupportTicketCountAggregateOutputType> | number
        }
      }
    }
    TicketResponse: {
      payload: Prisma.$TicketResponsePayload<ExtArgs>
      fields: Prisma.TicketResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TicketResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TicketResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>
        }
        findFirst: {
          args: Prisma.TicketResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TicketResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>
        }
        findMany: {
          args: Prisma.TicketResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>[]
        }
        create: {
          args: Prisma.TicketResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>
        }
        createMany: {
          args: Prisma.TicketResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TicketResponseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>[]
        }
        delete: {
          args: Prisma.TicketResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>
        }
        update: {
          args: Prisma.TicketResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>
        }
        deleteMany: {
          args: Prisma.TicketResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TicketResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TicketResponseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>[]
        }
        upsert: {
          args: Prisma.TicketResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketResponsePayload>
        }
        aggregate: {
          args: Prisma.TicketResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTicketResponse>
        }
        groupBy: {
          args: Prisma.TicketResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TicketResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.TicketResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TicketResponseCountAggregateOutputType> | number
        }
      }
    }
    TicketAttachment: {
      payload: Prisma.$TicketAttachmentPayload<ExtArgs>
      fields: Prisma.TicketAttachmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TicketAttachmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
        }
        findFirst: {
          args: Prisma.TicketAttachmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TicketAttachmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
        }
        findMany: {
          args: Prisma.TicketAttachmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
        }
        create: {
          args: Prisma.TicketAttachmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
        }
        createMany: {
          args: Prisma.TicketAttachmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TicketAttachmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
        }
        delete: {
          args: Prisma.TicketAttachmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
        }
        update: {
          args: Prisma.TicketAttachmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
        }
        deleteMany: {
          args: Prisma.TicketAttachmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TicketAttachmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
        }
        upsert: {
          args: Prisma.TicketAttachmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
        }
        aggregate: {
          args: Prisma.TicketAttachmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTicketAttachment>
        }
        groupBy: {
          args: Prisma.TicketAttachmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TicketAttachmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.TicketAttachmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TicketAttachmentCountAggregateOutputType> | number
        }
      }
    }
    Course: {
      payload: Prisma.$CoursePayload<ExtArgs>
      fields: Prisma.CourseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CourseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>
        }
        findFirst: {
          args: Prisma.CourseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>
        }
        findMany: {
          args: Prisma.CourseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>[]
        }
        create: {
          args: Prisma.CourseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>
        }
        createMany: {
          args: Prisma.CourseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>[]
        }
        delete: {
          args: Prisma.CourseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>
        }
        update: {
          args: Prisma.CourseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>
        }
        deleteMany: {
          args: Prisma.CourseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CourseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>[]
        }
        upsert: {
          args: Prisma.CourseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>
        }
        aggregate: {
          args: Prisma.CourseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCourse>
        }
        groupBy: {
          args: Prisma.CourseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseGroupByOutputType>[]
        }
        count: {
          args: Prisma.CourseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseCountAggregateOutputType> | number
        }
      }
    }
    CourseInstructor: {
      payload: Prisma.$CourseInstructorPayload<ExtArgs>
      fields: Prisma.CourseInstructorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CourseInstructorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CourseInstructorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>
        }
        findFirst: {
          args: Prisma.CourseInstructorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CourseInstructorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>
        }
        findMany: {
          args: Prisma.CourseInstructorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>[]
        }
        create: {
          args: Prisma.CourseInstructorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>
        }
        createMany: {
          args: Prisma.CourseInstructorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CourseInstructorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>[]
        }
        delete: {
          args: Prisma.CourseInstructorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>
        }
        update: {
          args: Prisma.CourseInstructorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>
        }
        deleteMany: {
          args: Prisma.CourseInstructorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CourseInstructorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CourseInstructorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>[]
        }
        upsert: {
          args: Prisma.CourseInstructorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseInstructorPayload>
        }
        aggregate: {
          args: Prisma.CourseInstructorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCourseInstructor>
        }
        groupBy: {
          args: Prisma.CourseInstructorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseInstructorGroupByOutputType>[]
        }
        count: {
          args: Prisma.CourseInstructorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseInstructorCountAggregateOutputType> | number
        }
      }
    }
    Instructor: {
      payload: Prisma.$InstructorPayload<ExtArgs>
      fields: Prisma.InstructorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstructorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstructorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>
        }
        findFirst: {
          args: Prisma.InstructorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstructorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>
        }
        findMany: {
          args: Prisma.InstructorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>[]
        }
        create: {
          args: Prisma.InstructorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>
        }
        createMany: {
          args: Prisma.InstructorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InstructorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>[]
        }
        delete: {
          args: Prisma.InstructorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>
        }
        update: {
          args: Prisma.InstructorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>
        }
        deleteMany: {
          args: Prisma.InstructorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstructorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InstructorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>[]
        }
        upsert: {
          args: Prisma.InstructorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstructorPayload>
        }
        aggregate: {
          args: Prisma.InstructorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstructor>
        }
        groupBy: {
          args: Prisma.InstructorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstructorGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstructorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstructorCountAggregateOutputType> | number
        }
      }
    }
    CourseCategory: {
      payload: Prisma.$CourseCategoryPayload<ExtArgs>
      fields: Prisma.CourseCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CourseCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CourseCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
        }
        findFirst: {
          args: Prisma.CourseCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CourseCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
        }
        findMany: {
          args: Prisma.CourseCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>[]
        }
        create: {
          args: Prisma.CourseCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
        }
        createMany: {
          args: Prisma.CourseCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CourseCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>[]
        }
        delete: {
          args: Prisma.CourseCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
        }
        update: {
          args: Prisma.CourseCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
        }
        deleteMany: {
          args: Prisma.CourseCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CourseCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CourseCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>[]
        }
        upsert: {
          args: Prisma.CourseCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseCategoryPayload>
        }
        aggregate: {
          args: Prisma.CourseCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCourseCategory>
        }
        groupBy: {
          args: Prisma.CourseCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CourseCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseCategoryCountAggregateOutputType> | number
        }
      }
    }
    CourseModule: {
      payload: Prisma.$CourseModulePayload<ExtArgs>
      fields: Prisma.CourseModuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CourseModuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CourseModuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>
        }
        findFirst: {
          args: Prisma.CourseModuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CourseModuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>
        }
        findMany: {
          args: Prisma.CourseModuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
        }
        create: {
          args: Prisma.CourseModuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>
        }
        createMany: {
          args: Prisma.CourseModuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CourseModuleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
        }
        delete: {
          args: Prisma.CourseModuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>
        }
        update: {
          args: Prisma.CourseModuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>
        }
        deleteMany: {
          args: Prisma.CourseModuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CourseModuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CourseModuleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
        }
        upsert: {
          args: Prisma.CourseModuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseModulePayload>
        }
        aggregate: {
          args: Prisma.CourseModuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCourseModule>
        }
        groupBy: {
          args: Prisma.CourseModuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseModuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.CourseModuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseModuleCountAggregateOutputType> | number
        }
      }
    }
    Lesson: {
      payload: Prisma.$LessonPayload<ExtArgs>
      fields: Prisma.LessonFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LessonFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>
        }
        findFirst: {
          args: Prisma.LessonFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>
        }
        findMany: {
          args: Prisma.LessonFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>[]
        }
        create: {
          args: Prisma.LessonCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>
        }
        createMany: {
          args: Prisma.LessonCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>[]
        }
        delete: {
          args: Prisma.LessonDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>
        }
        update: {
          args: Prisma.LessonUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>
        }
        deleteMany: {
          args: Prisma.LessonDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LessonUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>[]
        }
        upsert: {
          args: Prisma.LessonUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonPayload>
        }
        aggregate: {
          args: Prisma.LessonAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLesson>
        }
        groupBy: {
          args: Prisma.LessonGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LessonGroupByOutputType>[]
        }
        count: {
          args: Prisma.LessonCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LessonCountAggregateOutputType> | number
        }
      }
    }
    Enrollment: {
      payload: Prisma.$EnrollmentPayload<ExtArgs>
      fields: Prisma.EnrollmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>
        }
        findFirst: {
          args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>
        }
        findMany: {
          args: Prisma.EnrollmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
        }
        create: {
          args: Prisma.EnrollmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>
        }
        createMany: {
          args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
        }
        delete: {
          args: Prisma.EnrollmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>
        }
        update: {
          args: Prisma.EnrollmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>
        }
        deleteMany: {
          args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
        }
        upsert: {
          args: Prisma.EnrollmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>
        }
        aggregate: {
          args: Prisma.EnrollmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEnrollment>
        }
        groupBy: {
          args: Prisma.EnrollmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EnrollmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.EnrollmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EnrollmentCountAggregateOutputType> | number
        }
      }
    }
    Student: {
      payload: Prisma.$StudentPayload<ExtArgs>
      fields: Prisma.StudentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StudentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>
        }
        findFirst: {
          args: Prisma.StudentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>
        }
        findMany: {
          args: Prisma.StudentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>[]
        }
        create: {
          args: Prisma.StudentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>
        }
        createMany: {
          args: Prisma.StudentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>[]
        }
        delete: {
          args: Prisma.StudentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>
        }
        update: {
          args: Prisma.StudentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>
        }
        deleteMany: {
          args: Prisma.StudentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StudentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>[]
        }
        upsert: {
          args: Prisma.StudentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>
        }
        aggregate: {
          args: Prisma.StudentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStudent>
        }
        groupBy: {
          args: Prisma.StudentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StudentGroupByOutputType>[]
        }
        count: {
          args: Prisma.StudentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StudentCountAggregateOutputType> | number
        }
      }
    }
    LessonProgress: {
      payload: Prisma.$LessonProgressPayload<ExtArgs>
      fields: Prisma.LessonProgressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LessonProgressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LessonProgressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>
        }
        findFirst: {
          args: Prisma.LessonProgressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LessonProgressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>
        }
        findMany: {
          args: Prisma.LessonProgressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
        }
        create: {
          args: Prisma.LessonProgressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>
        }
        createMany: {
          args: Prisma.LessonProgressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LessonProgressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
        }
        delete: {
          args: Prisma.LessonProgressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>
        }
        update: {
          args: Prisma.LessonProgressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>
        }
        deleteMany: {
          args: Prisma.LessonProgressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LessonProgressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LessonProgressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
        }
        upsert: {
          args: Prisma.LessonProgressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LessonProgressPayload>
        }
        aggregate: {
          args: Prisma.LessonProgressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLessonProgress>
        }
        groupBy: {
          args: Prisma.LessonProgressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LessonProgressGroupByOutputType>[]
        }
        count: {
          args: Prisma.LessonProgressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LessonProgressCountAggregateOutputType> | number
        }
      }
    }
    Assignment: {
      payload: Prisma.$AssignmentPayload<ExtArgs>
      fields: Prisma.AssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>
        }
        findFirst: {
          args: Prisma.AssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>
        }
        findMany: {
          args: Prisma.AssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
        }
        create: {
          args: Prisma.AssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>
        }
        createMany: {
          args: Prisma.AssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
        }
        delete: {
          args: Prisma.AssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>
        }
        update: {
          args: Prisma.AssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>
        }
        deleteMany: {
          args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
        }
        upsert: {
          args: Prisma.AssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>
        }
        aggregate: {
          args: Prisma.AssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssignment>
        }
        groupBy: {
          args: Prisma.AssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssignmentCountAggregateOutputType> | number
        }
      }
    }
    AssignmentSubmission: {
      payload: Prisma.$AssignmentSubmissionPayload<ExtArgs>
      fields: Prisma.AssignmentSubmissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssignmentSubmissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
        }
        findFirst: {
          args: Prisma.AssignmentSubmissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
        }
        findMany: {
          args: Prisma.AssignmentSubmissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
        }
        create: {
          args: Prisma.AssignmentSubmissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
        }
        createMany: {
          args: Prisma.AssignmentSubmissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
        }
        delete: {
          args: Prisma.AssignmentSubmissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
        }
        update: {
          args: Prisma.AssignmentSubmissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
        }
        deleteMany: {
          args: Prisma.AssignmentSubmissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssignmentSubmissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
        }
        upsert: {
          args: Prisma.AssignmentSubmissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
        }
        aggregate: {
          args: Prisma.AssignmentSubmissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssignmentSubmission>
        }
        groupBy: {
          args: Prisma.AssignmentSubmissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssignmentSubmissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssignmentSubmissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssignmentSubmissionCountAggregateOutputType> | number
        }
      }
    }
    Quiz: {
      payload: Prisma.$QuizPayload<ExtArgs>
      fields: Prisma.QuizFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuizFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>
        }
        findFirst: {
          args: Prisma.QuizFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>
        }
        findMany: {
          args: Prisma.QuizFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>[]
        }
        create: {
          args: Prisma.QuizCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>
        }
        createMany: {
          args: Prisma.QuizCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>[]
        }
        delete: {
          args: Prisma.QuizDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>
        }
        update: {
          args: Prisma.QuizUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>
        }
        deleteMany: {
          args: Prisma.QuizDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuizUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>[]
        }
        upsert: {
          args: Prisma.QuizUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizPayload>
        }
        aggregate: {
          args: Prisma.QuizAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuiz>
        }
        groupBy: {
          args: Prisma.QuizGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuizCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizCountAggregateOutputType> | number
        }
      }
    }
    QuizQuestion: {
      payload: Prisma.$QuizQuestionPayload<ExtArgs>
      fields: Prisma.QuizQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
        }
        findFirst: {
          args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
        }
        findMany: {
          args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
        }
        create: {
          args: Prisma.QuizQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
        }
        createMany: {
          args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
        }
        delete: {
          args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
        }
        update: {
          args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
        }
        deleteMany: {
          args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
        }
        upsert: {
          args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
        }
        aggregate: {
          args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuizQuestion>
        }
        groupBy: {
          args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuizQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizQuestionCountAggregateOutputType> | number
        }
      }
    }
    QuizOption: {
      payload: Prisma.$QuizOptionPayload<ExtArgs>
      fields: Prisma.QuizOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuizOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuizOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>
        }
        findFirst: {
          args: Prisma.QuizOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuizOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>
        }
        findMany: {
          args: Prisma.QuizOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
        }
        create: {
          args: Prisma.QuizOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>
        }
        createMany: {
          args: Prisma.QuizOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuizOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
        }
        delete: {
          args: Prisma.QuizOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>
        }
        update: {
          args: Prisma.QuizOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>
        }
        deleteMany: {
          args: Prisma.QuizOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuizOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuizOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
        }
        upsert: {
          args: Prisma.QuizOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizOptionPayload>
        }
        aggregate: {
          args: Prisma.QuizOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuizOption>
        }
        groupBy: {
          args: Prisma.QuizOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuizOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizOptionCountAggregateOutputType> | number
        }
      }
    }
    QuizAttempt: {
      payload: Prisma.$QuizAttemptPayload<ExtArgs>
      fields: Prisma.QuizAttemptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
        }
        findFirst: {
          args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
        }
        findMany: {
          args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
        }
        create: {
          args: Prisma.QuizAttemptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
        }
        createMany: {
          args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
        }
        delete: {
          args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
        }
        update: {
          args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
        }
        deleteMany: {
          args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuizAttemptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
        }
        upsert: {
          args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
        }
        aggregate: {
          args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuizAttempt>
        }
        groupBy: {
          args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizAttemptGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuizAttemptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizAttemptCountAggregateOutputType> | number
        }
      }
    }
    QuizAnswer: {
      payload: Prisma.$QuizAnswerPayload<ExtArgs>
      fields: Prisma.QuizAnswerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuizAnswerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuizAnswerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
        }
        findFirst: {
          args: Prisma.QuizAnswerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuizAnswerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
        }
        findMany: {
          args: Prisma.QuizAnswerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
        }
        create: {
          args: Prisma.QuizAnswerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
        }
        createMany: {
          args: Prisma.QuizAnswerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuizAnswerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
        }
        delete: {
          args: Prisma.QuizAnswerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
        }
        update: {
          args: Prisma.QuizAnswerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
        }
        deleteMany: {
          args: Prisma.QuizAnswerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuizAnswerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuizAnswerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
        }
        upsert: {
          args: Prisma.QuizAnswerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
        }
        aggregate: {
          args: Prisma.QuizAnswerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuizAnswer>
        }
        groupBy: {
          args: Prisma.QuizAnswerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizAnswerGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuizAnswerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuizAnswerCountAggregateOutputType> | number
        }
      }
    }
    Certificate: {
      payload: Prisma.$CertificatePayload<ExtArgs>
      fields: Prisma.CertificateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CertificateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>
        }
        findFirst: {
          args: Prisma.CertificateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>
        }
        findMany: {
          args: Prisma.CertificateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>[]
        }
        create: {
          args: Prisma.CertificateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>
        }
        createMany: {
          args: Prisma.CertificateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>[]
        }
        delete: {
          args: Prisma.CertificateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>
        }
        update: {
          args: Prisma.CertificateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>
        }
        deleteMany: {
          args: Prisma.CertificateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CertificateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>[]
        }
        upsert: {
          args: Prisma.CertificateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CertificatePayload>
        }
        aggregate: {
          args: Prisma.CertificateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCertificate>
        }
        groupBy: {
          args: Prisma.CertificateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CertificateGroupByOutputType>[]
        }
        count: {
          args: Prisma.CertificateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CertificateCountAggregateOutputType> | number
        }
      }
    }
    CourseReview: {
      payload: Prisma.$CourseReviewPayload<ExtArgs>
      fields: Prisma.CourseReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CourseReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CourseReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>
        }
        findFirst: {
          args: Prisma.CourseReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CourseReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>
        }
        findMany: {
          args: Prisma.CourseReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
        }
        create: {
          args: Prisma.CourseReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>
        }
        createMany: {
          args: Prisma.CourseReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CourseReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
        }
        delete: {
          args: Prisma.CourseReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>
        }
        update: {
          args: Prisma.CourseReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>
        }
        deleteMany: {
          args: Prisma.CourseReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CourseReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CourseReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>[]
        }
        upsert: {
          args: Prisma.CourseReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CourseReviewPayload>
        }
        aggregate: {
          args: Prisma.CourseReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCourseReview>
        }
        groupBy: {
          args: Prisma.CourseReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.CourseReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CourseReviewCountAggregateOutputType> | number
        }
      }
    }
    Event: {
      payload: Prisma.$EventPayload<ExtArgs>
      fields: Prisma.EventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findFirst: {
          args: Prisma.EventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findMany: {
          args: Prisma.EventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        create: {
          args: Prisma.EventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        createMany: {
          args: Prisma.EventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        delete: {
          args: Prisma.EventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        update: {
          args: Prisma.EventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        deleteMany: {
          args: Prisma.EventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        upsert: {
          args: Prisma.EventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        aggregate: {
          args: Prisma.EventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvent>
        }
        groupBy: {
          args: Prisma.EventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCountAggregateOutputType> | number
        }
      }
    }
    Venue: {
      payload: Prisma.$VenuePayload<ExtArgs>
      fields: Prisma.VenueFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VenueFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>
        }
        findFirst: {
          args: Prisma.VenueFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>
        }
        findMany: {
          args: Prisma.VenueFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>[]
        }
        create: {
          args: Prisma.VenueCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>
        }
        createMany: {
          args: Prisma.VenueCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VenueCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>[]
        }
        delete: {
          args: Prisma.VenueDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>
        }
        update: {
          args: Prisma.VenueUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>
        }
        deleteMany: {
          args: Prisma.VenueDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VenueUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VenueUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>[]
        }
        upsert: {
          args: Prisma.VenueUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VenuePayload>
        }
        aggregate: {
          args: Prisma.VenueAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVenue>
        }
        groupBy: {
          args: Prisma.VenueGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VenueGroupByOutputType>[]
        }
        count: {
          args: Prisma.VenueCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VenueCountAggregateOutputType> | number
        }
      }
    }
    EventTicket: {
      payload: Prisma.$EventTicketPayload<ExtArgs>
      fields: Prisma.EventTicketFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventTicketFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventTicketFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>
        }
        findFirst: {
          args: Prisma.EventTicketFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventTicketFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>
        }
        findMany: {
          args: Prisma.EventTicketFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>[]
        }
        create: {
          args: Prisma.EventTicketCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>
        }
        createMany: {
          args: Prisma.EventTicketCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventTicketCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>[]
        }
        delete: {
          args: Prisma.EventTicketDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>
        }
        update: {
          args: Prisma.EventTicketUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>
        }
        deleteMany: {
          args: Prisma.EventTicketDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventTicketUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventTicketUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>[]
        }
        upsert: {
          args: Prisma.EventTicketUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketPayload>
        }
        aggregate: {
          args: Prisma.EventTicketAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventTicket>
        }
        groupBy: {
          args: Prisma.EventTicketGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTicketGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventTicketCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTicketCountAggregateOutputType> | number
        }
      }
    }
    EventRegistration: {
      payload: Prisma.$EventRegistrationPayload<ExtArgs>
      fields: Prisma.EventRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findFirst: {
          args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findMany: {
          args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        create: {
          args: Prisma.EventRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        createMany: {
          args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        delete: {
          args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        update: {
          args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        aggregate: {
          args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventRegistration>
        }
        groupBy: {
          args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationCountAggregateOutputType> | number
        }
      }
    }
    Attendee: {
      payload: Prisma.$AttendeePayload<ExtArgs>
      fields: Prisma.AttendeeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendeeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendeeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>
        }
        findFirst: {
          args: Prisma.AttendeeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendeeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>
        }
        findMany: {
          args: Prisma.AttendeeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>[]
        }
        create: {
          args: Prisma.AttendeeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>
        }
        createMany: {
          args: Prisma.AttendeeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendeeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>[]
        }
        delete: {
          args: Prisma.AttendeeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>
        }
        update: {
          args: Prisma.AttendeeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>
        }
        deleteMany: {
          args: Prisma.AttendeeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendeeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendeeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>[]
        }
        upsert: {
          args: Prisma.AttendeeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendeePayload>
        }
        aggregate: {
          args: Prisma.AttendeeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendee>
        }
        groupBy: {
          args: Prisma.AttendeeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendeeGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendeeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendeeCountAggregateOutputType> | number
        }
      }
    }
    EventSession: {
      payload: Prisma.$EventSessionPayload<ExtArgs>
      fields: Prisma.EventSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>
        }
        findFirst: {
          args: Prisma.EventSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>
        }
        findMany: {
          args: Prisma.EventSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>[]
        }
        create: {
          args: Prisma.EventSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>
        }
        createMany: {
          args: Prisma.EventSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>[]
        }
        delete: {
          args: Prisma.EventSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>
        }
        update: {
          args: Prisma.EventSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>
        }
        deleteMany: {
          args: Prisma.EventSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>[]
        }
        upsert: {
          args: Prisma.EventSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSessionPayload>
        }
        aggregate: {
          args: Prisma.EventSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventSession>
        }
        groupBy: {
          args: Prisma.EventSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSessionCountAggregateOutputType> | number
        }
      }
    }
    Speaker: {
      payload: Prisma.$SpeakerPayload<ExtArgs>
      fields: Prisma.SpeakerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SpeakerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SpeakerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>
        }
        findFirst: {
          args: Prisma.SpeakerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SpeakerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>
        }
        findMany: {
          args: Prisma.SpeakerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
        }
        create: {
          args: Prisma.SpeakerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>
        }
        createMany: {
          args: Prisma.SpeakerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SpeakerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
        }
        delete: {
          args: Prisma.SpeakerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>
        }
        update: {
          args: Prisma.SpeakerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>
        }
        deleteMany: {
          args: Prisma.SpeakerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SpeakerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SpeakerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
        }
        upsert: {
          args: Prisma.SpeakerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SpeakerPayload>
        }
        aggregate: {
          args: Prisma.SpeakerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSpeaker>
        }
        groupBy: {
          args: Prisma.SpeakerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SpeakerGroupByOutputType>[]
        }
        count: {
          args: Prisma.SpeakerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SpeakerCountAggregateOutputType> | number
        }
      }
    }
    EventSpeaker: {
      payload: Prisma.$EventSpeakerPayload<ExtArgs>
      fields: Prisma.EventSpeakerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventSpeakerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventSpeakerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>
        }
        findFirst: {
          args: Prisma.EventSpeakerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventSpeakerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>
        }
        findMany: {
          args: Prisma.EventSpeakerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>[]
        }
        create: {
          args: Prisma.EventSpeakerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>
        }
        createMany: {
          args: Prisma.EventSpeakerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventSpeakerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>[]
        }
        delete: {
          args: Prisma.EventSpeakerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>
        }
        update: {
          args: Prisma.EventSpeakerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>
        }
        deleteMany: {
          args: Prisma.EventSpeakerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventSpeakerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventSpeakerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>[]
        }
        upsert: {
          args: Prisma.EventSpeakerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSpeakerPayload>
        }
        aggregate: {
          args: Prisma.EventSpeakerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventSpeaker>
        }
        groupBy: {
          args: Prisma.EventSpeakerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSpeakerGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventSpeakerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSpeakerCountAggregateOutputType> | number
        }
      }
    }
    SessionSpeaker: {
      payload: Prisma.$SessionSpeakerPayload<ExtArgs>
      fields: Prisma.SessionSpeakerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionSpeakerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionSpeakerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
        }
        findFirst: {
          args: Prisma.SessionSpeakerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionSpeakerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
        }
        findMany: {
          args: Prisma.SessionSpeakerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>[]
        }
        create: {
          args: Prisma.SessionSpeakerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
        }
        createMany: {
          args: Prisma.SessionSpeakerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionSpeakerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>[]
        }
        delete: {
          args: Prisma.SessionSpeakerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
        }
        update: {
          args: Prisma.SessionSpeakerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
        }
        deleteMany: {
          args: Prisma.SessionSpeakerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionSpeakerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionSpeakerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>[]
        }
        upsert: {
          args: Prisma.SessionSpeakerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
        }
        aggregate: {
          args: Prisma.SessionSpeakerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSessionSpeaker>
        }
        groupBy: {
          args: Prisma.SessionSpeakerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionSpeakerGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionSpeakerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionSpeakerCountAggregateOutputType> | number
        }
      }
    }
    Sponsor: {
      payload: Prisma.$SponsorPayload<ExtArgs>
      fields: Prisma.SponsorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SponsorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SponsorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>
        }
        findFirst: {
          args: Prisma.SponsorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SponsorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>
        }
        findMany: {
          args: Prisma.SponsorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>[]
        }
        create: {
          args: Prisma.SponsorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>
        }
        createMany: {
          args: Prisma.SponsorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SponsorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>[]
        }
        delete: {
          args: Prisma.SponsorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>
        }
        update: {
          args: Prisma.SponsorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>
        }
        deleteMany: {
          args: Prisma.SponsorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SponsorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SponsorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>[]
        }
        upsert: {
          args: Prisma.SponsorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SponsorPayload>
        }
        aggregate: {
          args: Prisma.SponsorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSponsor>
        }
        groupBy: {
          args: Prisma.SponsorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SponsorGroupByOutputType>[]
        }
        count: {
          args: Prisma.SponsorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SponsorCountAggregateOutputType> | number
        }
      }
    }
    EventSponsor: {
      payload: Prisma.$EventSponsorPayload<ExtArgs>
      fields: Prisma.EventSponsorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventSponsorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventSponsorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>
        }
        findFirst: {
          args: Prisma.EventSponsorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventSponsorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>
        }
        findMany: {
          args: Prisma.EventSponsorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>[]
        }
        create: {
          args: Prisma.EventSponsorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>
        }
        createMany: {
          args: Prisma.EventSponsorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventSponsorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>[]
        }
        delete: {
          args: Prisma.EventSponsorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>
        }
        update: {
          args: Prisma.EventSponsorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>
        }
        deleteMany: {
          args: Prisma.EventSponsorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventSponsorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventSponsorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>[]
        }
        upsert: {
          args: Prisma.EventSponsorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorPayload>
        }
        aggregate: {
          args: Prisma.EventSponsorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventSponsor>
        }
        groupBy: {
          args: Prisma.EventSponsorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSponsorGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventSponsorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSponsorCountAggregateOutputType> | number
        }
      }
    }
    Folder: {
      payload: Prisma.$FolderPayload<ExtArgs>
      fields: Prisma.FolderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FolderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        findFirst: {
          args: Prisma.FolderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        findMany: {
          args: Prisma.FolderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>[]
        }
        create: {
          args: Prisma.FolderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        createMany: {
          args: Prisma.FolderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>[]
        }
        delete: {
          args: Prisma.FolderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        update: {
          args: Prisma.FolderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        deleteMany: {
          args: Prisma.FolderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FolderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>[]
        }
        upsert: {
          args: Prisma.FolderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        aggregate: {
          args: Prisma.FolderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFolder>
        }
        groupBy: {
          args: Prisma.FolderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderGroupByOutputType>[]
        }
        count: {
          args: Prisma.FolderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderCountAggregateOutputType> | number
        }
      }
    }
    File: {
      payload: Prisma.$FilePayload<ExtArgs>
      fields: Prisma.FileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        findFirst: {
          args: Prisma.FileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        findMany: {
          args: Prisma.FileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[]
        }
        create: {
          args: Prisma.FileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        createMany: {
          args: Prisma.FileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[]
        }
        delete: {
          args: Prisma.FileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        update: {
          args: Prisma.FileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        deleteMany: {
          args: Prisma.FileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[]
        }
        upsert: {
          args: Prisma.FileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        aggregate: {
          args: Prisma.FileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFile>
        }
        groupBy: {
          args: Prisma.FileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileGroupByOutputType>[]
        }
        count: {
          args: Prisma.FileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileCountAggregateOutputType> | number
        }
      }
    }
    FileVersion: {
      payload: Prisma.$FileVersionPayload<ExtArgs>
      fields: Prisma.FileVersionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FileVersionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FileVersionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>
        }
        findFirst: {
          args: Prisma.FileVersionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FileVersionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>
        }
        findMany: {
          args: Prisma.FileVersionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>[]
        }
        create: {
          args: Prisma.FileVersionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>
        }
        createMany: {
          args: Prisma.FileVersionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FileVersionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>[]
        }
        delete: {
          args: Prisma.FileVersionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>
        }
        update: {
          args: Prisma.FileVersionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>
        }
        deleteMany: {
          args: Prisma.FileVersionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FileVersionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FileVersionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>[]
        }
        upsert: {
          args: Prisma.FileVersionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileVersionPayload>
        }
        aggregate: {
          args: Prisma.FileVersionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFileVersion>
        }
        groupBy: {
          args: Prisma.FileVersionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileVersionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FileVersionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileVersionCountAggregateOutputType> | number
        }
      }
    }
    FileShare: {
      payload: Prisma.$FileSharePayload<ExtArgs>
      fields: Prisma.FileShareFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FileShareFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FileShareFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>
        }
        findFirst: {
          args: Prisma.FileShareFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FileShareFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>
        }
        findMany: {
          args: Prisma.FileShareFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>[]
        }
        create: {
          args: Prisma.FileShareCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>
        }
        createMany: {
          args: Prisma.FileShareCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FileShareCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>[]
        }
        delete: {
          args: Prisma.FileShareDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>
        }
        update: {
          args: Prisma.FileShareUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>
        }
        deleteMany: {
          args: Prisma.FileShareDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FileShareUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FileShareUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>[]
        }
        upsert: {
          args: Prisma.FileShareUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileSharePayload>
        }
        aggregate: {
          args: Prisma.FileShareAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFileShare>
        }
        groupBy: {
          args: Prisma.FileShareGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileShareGroupByOutputType>[]
        }
        count: {
          args: Prisma.FileShareCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileShareCountAggregateOutputType> | number
        }
      }
    }
    FolderShare: {
      payload: Prisma.$FolderSharePayload<ExtArgs>
      fields: Prisma.FolderShareFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FolderShareFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FolderShareFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>
        }
        findFirst: {
          args: Prisma.FolderShareFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FolderShareFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>
        }
        findMany: {
          args: Prisma.FolderShareFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>[]
        }
        create: {
          args: Prisma.FolderShareCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>
        }
        createMany: {
          args: Prisma.FolderShareCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FolderShareCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>[]
        }
        delete: {
          args: Prisma.FolderShareDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>
        }
        update: {
          args: Prisma.FolderShareUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>
        }
        deleteMany: {
          args: Prisma.FolderShareDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FolderShareUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FolderShareUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>[]
        }
        upsert: {
          args: Prisma.FolderShareUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderSharePayload>
        }
        aggregate: {
          args: Prisma.FolderShareAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFolderShare>
        }
        groupBy: {
          args: Prisma.FolderShareGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderShareGroupByOutputType>[]
        }
        count: {
          args: Prisma.FolderShareCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderShareCountAggregateOutputType> | number
        }
      }
    }
    FilePermission: {
      payload: Prisma.$FilePermissionPayload<ExtArgs>
      fields: Prisma.FilePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FilePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FilePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>
        }
        findFirst: {
          args: Prisma.FilePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FilePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>
        }
        findMany: {
          args: Prisma.FilePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>[]
        }
        create: {
          args: Prisma.FilePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>
        }
        createMany: {
          args: Prisma.FilePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FilePermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>[]
        }
        delete: {
          args: Prisma.FilePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>
        }
        update: {
          args: Prisma.FilePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>
        }
        deleteMany: {
          args: Prisma.FilePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FilePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FilePermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>[]
        }
        upsert: {
          args: Prisma.FilePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePermissionPayload>
        }
        aggregate: {
          args: Prisma.FilePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFilePermission>
        }
        groupBy: {
          args: Prisma.FilePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FilePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilePermissionCountAggregateOutputType> | number
        }
      }
    }
    FileDownload: {
      payload: Prisma.$FileDownloadPayload<ExtArgs>
      fields: Prisma.FileDownloadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FileDownloadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FileDownloadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>
        }
        findFirst: {
          args: Prisma.FileDownloadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FileDownloadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>
        }
        findMany: {
          args: Prisma.FileDownloadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>[]
        }
        create: {
          args: Prisma.FileDownloadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>
        }
        createMany: {
          args: Prisma.FileDownloadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FileDownloadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>[]
        }
        delete: {
          args: Prisma.FileDownloadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>
        }
        update: {
          args: Prisma.FileDownloadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>
        }
        deleteMany: {
          args: Prisma.FileDownloadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FileDownloadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FileDownloadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>[]
        }
        upsert: {
          args: Prisma.FileDownloadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileDownloadPayload>
        }
        aggregate: {
          args: Prisma.FileDownloadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFileDownload>
        }
        groupBy: {
          args: Prisma.FileDownloadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileDownloadGroupByOutputType>[]
        }
        count: {
          args: Prisma.FileDownloadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileDownloadCountAggregateOutputType> | number
        }
      }
    }
    PageView: {
      payload: Prisma.$PageViewPayload<ExtArgs>
      fields: Prisma.PageViewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PageViewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PageViewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>
        }
        findFirst: {
          args: Prisma.PageViewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PageViewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>
        }
        findMany: {
          args: Prisma.PageViewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>[]
        }
        create: {
          args: Prisma.PageViewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>
        }
        createMany: {
          args: Prisma.PageViewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PageViewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>[]
        }
        delete: {
          args: Prisma.PageViewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>
        }
        update: {
          args: Prisma.PageViewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>
        }
        deleteMany: {
          args: Prisma.PageViewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PageViewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PageViewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>[]
        }
        upsert: {
          args: Prisma.PageViewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageViewPayload>
        }
        aggregate: {
          args: Prisma.PageViewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePageView>
        }
        groupBy: {
          args: Prisma.PageViewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageViewGroupByOutputType>[]
        }
        count: {
          args: Prisma.PageViewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageViewCountAggregateOutputType> | number
        }
      }
    }
    AnalyticsSession: {
      payload: Prisma.$AnalyticsSessionPayload<ExtArgs>
      fields: Prisma.AnalyticsSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnalyticsSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnalyticsSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
        }
        findFirst: {
          args: Prisma.AnalyticsSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnalyticsSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
        }
        findMany: {
          args: Prisma.AnalyticsSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>[]
        }
        create: {
          args: Prisma.AnalyticsSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
        }
        createMany: {
          args: Prisma.AnalyticsSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnalyticsSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>[]
        }
        delete: {
          args: Prisma.AnalyticsSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
        }
        update: {
          args: Prisma.AnalyticsSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
        }
        deleteMany: {
          args: Prisma.AnalyticsSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnalyticsSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnalyticsSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>[]
        }
        upsert: {
          args: Prisma.AnalyticsSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
        }
        aggregate: {
          args: Prisma.AnalyticsSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnalyticsSession>
        }
        groupBy: {
          args: Prisma.AnalyticsSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnalyticsSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnalyticsSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnalyticsSessionCountAggregateOutputType> | number
        }
      }
    }
    AnalyticsEvent: {
      payload: Prisma.$AnalyticsEventPayload<ExtArgs>
      fields: Prisma.AnalyticsEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
        }
        findFirst: {
          args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
        }
        findMany: {
          args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
        }
        create: {
          args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
        }
        createMany: {
          args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
        }
        delete: {
          args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
        }
        update: {
          args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
        }
        deleteMany: {
          args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
        }
        upsert: {
          args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
        }
        aggregate: {
          args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnalyticsEvent>
        }
        groupBy: {
          args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnalyticsEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnalyticsEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnalyticsEventCountAggregateOutputType> | number
        }
      }
    }
    ConversionGoal: {
      payload: Prisma.$ConversionGoalPayload<ExtArgs>
      fields: Prisma.ConversionGoalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversionGoalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversionGoalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>
        }
        findFirst: {
          args: Prisma.ConversionGoalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversionGoalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>
        }
        findMany: {
          args: Prisma.ConversionGoalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>[]
        }
        create: {
          args: Prisma.ConversionGoalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>
        }
        createMany: {
          args: Prisma.ConversionGoalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversionGoalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>[]
        }
        delete: {
          args: Prisma.ConversionGoalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>
        }
        update: {
          args: Prisma.ConversionGoalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>
        }
        deleteMany: {
          args: Prisma.ConversionGoalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversionGoalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversionGoalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>[]
        }
        upsert: {
          args: Prisma.ConversionGoalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionGoalPayload>
        }
        aggregate: {
          args: Prisma.ConversionGoalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversionGoal>
        }
        groupBy: {
          args: Prisma.ConversionGoalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversionGoalGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversionGoalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversionGoalCountAggregateOutputType> | number
        }
      }
    }
    Conversion: {
      payload: Prisma.$ConversionPayload<ExtArgs>
      fields: Prisma.ConversionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>
        }
        findFirst: {
          args: Prisma.ConversionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>
        }
        findMany: {
          args: Prisma.ConversionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>[]
        }
        create: {
          args: Prisma.ConversionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>
        }
        createMany: {
          args: Prisma.ConversionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>[]
        }
        delete: {
          args: Prisma.ConversionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>
        }
        update: {
          args: Prisma.ConversionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>
        }
        deleteMany: {
          args: Prisma.ConversionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>[]
        }
        upsert: {
          args: Prisma.ConversionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversionPayload>
        }
        aggregate: {
          args: Prisma.ConversionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversion>
        }
        groupBy: {
          args: Prisma.ConversionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversionCountAggregateOutputType> | number
        }
      }
    }
    ABTest: {
      payload: Prisma.$ABTestPayload<ExtArgs>
      fields: Prisma.ABTestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ABTestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ABTestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>
        }
        findFirst: {
          args: Prisma.ABTestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ABTestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>
        }
        findMany: {
          args: Prisma.ABTestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>[]
        }
        create: {
          args: Prisma.ABTestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>
        }
        createMany: {
          args: Prisma.ABTestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ABTestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>[]
        }
        delete: {
          args: Prisma.ABTestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>
        }
        update: {
          args: Prisma.ABTestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>
        }
        deleteMany: {
          args: Prisma.ABTestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ABTestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ABTestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>[]
        }
        upsert: {
          args: Prisma.ABTestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestPayload>
        }
        aggregate: {
          args: Prisma.ABTestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateABTest>
        }
        groupBy: {
          args: Prisma.ABTestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ABTestGroupByOutputType>[]
        }
        count: {
          args: Prisma.ABTestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ABTestCountAggregateOutputType> | number
        }
      }
    }
    ABTestVariant: {
      payload: Prisma.$ABTestVariantPayload<ExtArgs>
      fields: Prisma.ABTestVariantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ABTestVariantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ABTestVariantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>
        }
        findFirst: {
          args: Prisma.ABTestVariantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ABTestVariantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>
        }
        findMany: {
          args: Prisma.ABTestVariantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>[]
        }
        create: {
          args: Prisma.ABTestVariantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>
        }
        createMany: {
          args: Prisma.ABTestVariantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ABTestVariantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>[]
        }
        delete: {
          args: Prisma.ABTestVariantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>
        }
        update: {
          args: Prisma.ABTestVariantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>
        }
        deleteMany: {
          args: Prisma.ABTestVariantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ABTestVariantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ABTestVariantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>[]
        }
        upsert: {
          args: Prisma.ABTestVariantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestVariantPayload>
        }
        aggregate: {
          args: Prisma.ABTestVariantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateABTestVariant>
        }
        groupBy: {
          args: Prisma.ABTestVariantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ABTestVariantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ABTestVariantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ABTestVariantCountAggregateOutputType> | number
        }
      }
    }
    ABTestAssignment: {
      payload: Prisma.$ABTestAssignmentPayload<ExtArgs>
      fields: Prisma.ABTestAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ABTestAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ABTestAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>
        }
        findFirst: {
          args: Prisma.ABTestAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ABTestAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>
        }
        findMany: {
          args: Prisma.ABTestAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>[]
        }
        create: {
          args: Prisma.ABTestAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>
        }
        createMany: {
          args: Prisma.ABTestAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ABTestAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>[]
        }
        delete: {
          args: Prisma.ABTestAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>
        }
        update: {
          args: Prisma.ABTestAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.ABTestAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ABTestAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ABTestAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.ABTestAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ABTestAssignmentPayload>
        }
        aggregate: {
          args: Prisma.ABTestAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateABTestAssignment>
        }
        groupBy: {
          args: Prisma.ABTestAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ABTestAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ABTestAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ABTestAssignmentCountAggregateOutputType> | number
        }
      }
    }
    Campaign: {
      payload: Prisma.$CampaignPayload<ExtArgs>
      fields: Prisma.CampaignFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampaignFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        findFirst: {
          args: Prisma.CampaignFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        findMany: {
          args: Prisma.CampaignFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>[]
        }
        create: {
          args: Prisma.CampaignCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        createMany: {
          args: Prisma.CampaignCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>[]
        }
        delete: {
          args: Prisma.CampaignDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        update: {
          args: Prisma.CampaignUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        deleteMany: {
          args: Prisma.CampaignDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampaignUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>[]
        }
        upsert: {
          args: Prisma.CampaignUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        aggregate: {
          args: Prisma.CampaignAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampaign>
        }
        groupBy: {
          args: Prisma.CampaignGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampaignCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignCountAggregateOutputType> | number
        }
      }
    }
    CampaignEmail: {
      payload: Prisma.$CampaignEmailPayload<ExtArgs>
      fields: Prisma.CampaignEmailFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampaignEmailFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampaignEmailFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>
        }
        findFirst: {
          args: Prisma.CampaignEmailFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampaignEmailFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>
        }
        findMany: {
          args: Prisma.CampaignEmailFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>[]
        }
        create: {
          args: Prisma.CampaignEmailCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>
        }
        createMany: {
          args: Prisma.CampaignEmailCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampaignEmailCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>[]
        }
        delete: {
          args: Prisma.CampaignEmailDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>
        }
        update: {
          args: Prisma.CampaignEmailUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>
        }
        deleteMany: {
          args: Prisma.CampaignEmailDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampaignEmailUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampaignEmailUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>[]
        }
        upsert: {
          args: Prisma.CampaignEmailUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignEmailPayload>
        }
        aggregate: {
          args: Prisma.CampaignEmailAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampaignEmail>
        }
        groupBy: {
          args: Prisma.CampaignEmailGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignEmailGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampaignEmailCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignEmailCountAggregateOutputType> | number
        }
      }
    }
    EmailRecipient: {
      payload: Prisma.$EmailRecipientPayload<ExtArgs>
      fields: Prisma.EmailRecipientFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailRecipientFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailRecipientFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
        }
        findFirst: {
          args: Prisma.EmailRecipientFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailRecipientFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
        }
        findMany: {
          args: Prisma.EmailRecipientFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[]
        }
        create: {
          args: Prisma.EmailRecipientCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
        }
        createMany: {
          args: Prisma.EmailRecipientCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmailRecipientCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[]
        }
        delete: {
          args: Prisma.EmailRecipientDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
        }
        update: {
          args: Prisma.EmailRecipientUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
        }
        deleteMany: {
          args: Prisma.EmailRecipientDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailRecipientUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmailRecipientUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[]
        }
        upsert: {
          args: Prisma.EmailRecipientUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>
        }
        aggregate: {
          args: Prisma.EmailRecipientAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailRecipient>
        }
        groupBy: {
          args: Prisma.EmailRecipientGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailRecipientGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailRecipientCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailRecipientCountAggregateOutputType> | number
        }
      }
    }
    Segment: {
      payload: Prisma.$SegmentPayload<ExtArgs>
      fields: Prisma.SegmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SegmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SegmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>
        }
        findFirst: {
          args: Prisma.SegmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SegmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>
        }
        findMany: {
          args: Prisma.SegmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>[]
        }
        create: {
          args: Prisma.SegmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>
        }
        createMany: {
          args: Prisma.SegmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SegmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>[]
        }
        delete: {
          args: Prisma.SegmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>
        }
        update: {
          args: Prisma.SegmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>
        }
        deleteMany: {
          args: Prisma.SegmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SegmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SegmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>[]
        }
        upsert: {
          args: Prisma.SegmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentPayload>
        }
        aggregate: {
          args: Prisma.SegmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSegment>
        }
        groupBy: {
          args: Prisma.SegmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SegmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.SegmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SegmentCountAggregateOutputType> | number
        }
      }
    }
    CampaignSegment: {
      payload: Prisma.$CampaignSegmentPayload<ExtArgs>
      fields: Prisma.CampaignSegmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampaignSegmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampaignSegmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>
        }
        findFirst: {
          args: Prisma.CampaignSegmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampaignSegmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>
        }
        findMany: {
          args: Prisma.CampaignSegmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>[]
        }
        create: {
          args: Prisma.CampaignSegmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>
        }
        createMany: {
          args: Prisma.CampaignSegmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampaignSegmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>[]
        }
        delete: {
          args: Prisma.CampaignSegmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>
        }
        update: {
          args: Prisma.CampaignSegmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>
        }
        deleteMany: {
          args: Prisma.CampaignSegmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampaignSegmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampaignSegmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>[]
        }
        upsert: {
          args: Prisma.CampaignSegmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignSegmentPayload>
        }
        aggregate: {
          args: Prisma.CampaignSegmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampaignSegment>
        }
        groupBy: {
          args: Prisma.CampaignSegmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignSegmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampaignSegmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignSegmentCountAggregateOutputType> | number
        }
      }
    }
    SegmentSubscriber: {
      payload: Prisma.$SegmentSubscriberPayload<ExtArgs>
      fields: Prisma.SegmentSubscriberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SegmentSubscriberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SegmentSubscriberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>
        }
        findFirst: {
          args: Prisma.SegmentSubscriberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SegmentSubscriberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>
        }
        findMany: {
          args: Prisma.SegmentSubscriberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>[]
        }
        create: {
          args: Prisma.SegmentSubscriberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>
        }
        createMany: {
          args: Prisma.SegmentSubscriberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SegmentSubscriberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>[]
        }
        delete: {
          args: Prisma.SegmentSubscriberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>
        }
        update: {
          args: Prisma.SegmentSubscriberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>
        }
        deleteMany: {
          args: Prisma.SegmentSubscriberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SegmentSubscriberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SegmentSubscriberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>[]
        }
        upsert: {
          args: Prisma.SegmentSubscriberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SegmentSubscriberPayload>
        }
        aggregate: {
          args: Prisma.SegmentSubscriberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSegmentSubscriber>
        }
        groupBy: {
          args: Prisma.SegmentSubscriberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SegmentSubscriberGroupByOutputType>[]
        }
        count: {
          args: Prisma.SegmentSubscriberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SegmentSubscriberCountAggregateOutputType> | number
        }
      }
    }
    Subscriber: {
      payload: Prisma.$SubscriberPayload<ExtArgs>
      fields: Prisma.SubscriberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubscriberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubscriberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>
        }
        findFirst: {
          args: Prisma.SubscriberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubscriberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>
        }
        findMany: {
          args: Prisma.SubscriberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
        }
        create: {
          args: Prisma.SubscriberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>
        }
        createMany: {
          args: Prisma.SubscriberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubscriberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
        }
        delete: {
          args: Prisma.SubscriberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>
        }
        update: {
          args: Prisma.SubscriberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>
        }
        deleteMany: {
          args: Prisma.SubscriberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubscriberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubscriberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
        }
        upsert: {
          args: Prisma.SubscriberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriberPayload>
        }
        aggregate: {
          args: Prisma.SubscriberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscriber>
        }
        groupBy: {
          args: Prisma.SubscriberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriberGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubscriberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriberCountAggregateOutputType> | number
        }
      }
    }
    Newsletter: {
      payload: Prisma.$NewsletterPayload<ExtArgs>
      fields: Prisma.NewsletterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsletterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsletterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>
        }
        findFirst: {
          args: Prisma.NewsletterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsletterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>
        }
        findMany: {
          args: Prisma.NewsletterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>[]
        }
        create: {
          args: Prisma.NewsletterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>
        }
        createMany: {
          args: Prisma.NewsletterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsletterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>[]
        }
        delete: {
          args: Prisma.NewsletterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>
        }
        update: {
          args: Prisma.NewsletterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>
        }
        deleteMany: {
          args: Prisma.NewsletterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsletterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsletterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>[]
        }
        upsert: {
          args: Prisma.NewsletterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterPayload>
        }
        aggregate: {
          args: Prisma.NewsletterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsletter>
        }
        groupBy: {
          args: Prisma.NewsletterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsletterGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsletterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsletterCountAggregateOutputType> | number
        }
      }
    }
    NewsletterSubscriber: {
      payload: Prisma.$NewsletterSubscriberPayload<ExtArgs>
      fields: Prisma.NewsletterSubscriberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsletterSubscriberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsletterSubscriberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
        }
        findFirst: {
          args: Prisma.NewsletterSubscriberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsletterSubscriberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
        }
        findMany: {
          args: Prisma.NewsletterSubscriberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
        }
        create: {
          args: Prisma.NewsletterSubscriberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
        }
        createMany: {
          args: Prisma.NewsletterSubscriberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsletterSubscriberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
        }
        delete: {
          args: Prisma.NewsletterSubscriberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
        }
        update: {
          args: Prisma.NewsletterSubscriberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
        }
        deleteMany: {
          args: Prisma.NewsletterSubscriberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsletterSubscriberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsletterSubscriberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
        }
        upsert: {
          args: Prisma.NewsletterSubscriberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
        }
        aggregate: {
          args: Prisma.NewsletterSubscriberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsletterSubscriber>
        }
        groupBy: {
          args: Prisma.NewsletterSubscriberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsletterSubscriberGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsletterSubscriberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsletterSubscriberCountAggregateOutputType> | number
        }
      }
    }
    NewsletterIssue: {
      payload: Prisma.$NewsletterIssuePayload<ExtArgs>
      fields: Prisma.NewsletterIssueFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsletterIssueFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsletterIssueFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>
        }
        findFirst: {
          args: Prisma.NewsletterIssueFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsletterIssueFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>
        }
        findMany: {
          args: Prisma.NewsletterIssueFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>[]
        }
        create: {
          args: Prisma.NewsletterIssueCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>
        }
        createMany: {
          args: Prisma.NewsletterIssueCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsletterIssueCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>[]
        }
        delete: {
          args: Prisma.NewsletterIssueDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>
        }
        update: {
          args: Prisma.NewsletterIssueUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>
        }
        deleteMany: {
          args: Prisma.NewsletterIssueDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsletterIssueUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsletterIssueUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>[]
        }
        upsert: {
          args: Prisma.NewsletterIssueUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsletterIssuePayload>
        }
        aggregate: {
          args: Prisma.NewsletterIssueAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsletterIssue>
        }
        groupBy: {
          args: Prisma.NewsletterIssueGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsletterIssueGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsletterIssueCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsletterIssueCountAggregateOutputType> | number
        }
      }
    }
    LandingPage: {
      payload: Prisma.$LandingPagePayload<ExtArgs>
      fields: Prisma.LandingPageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LandingPageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LandingPageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>
        }
        findFirst: {
          args: Prisma.LandingPageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LandingPageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>
        }
        findMany: {
          args: Prisma.LandingPageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
        }
        create: {
          args: Prisma.LandingPageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>
        }
        createMany: {
          args: Prisma.LandingPageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LandingPageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
        }
        delete: {
          args: Prisma.LandingPageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>
        }
        update: {
          args: Prisma.LandingPageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>
        }
        deleteMany: {
          args: Prisma.LandingPageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LandingPageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LandingPageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
        }
        upsert: {
          args: Prisma.LandingPageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LandingPagePayload>
        }
        aggregate: {
          args: Prisma.LandingPageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLandingPage>
        }
        groupBy: {
          args: Prisma.LandingPageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LandingPageGroupByOutputType>[]
        }
        count: {
          args: Prisma.LandingPageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LandingPageCountAggregateOutputType> | number
        }
      }
    }
    Calendar: {
      payload: Prisma.$CalendarPayload<ExtArgs>
      fields: Prisma.CalendarFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CalendarFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CalendarFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        findFirst: {
          args: Prisma.CalendarFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CalendarFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        findMany: {
          args: Prisma.CalendarFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>[]
        }
        create: {
          args: Prisma.CalendarCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        createMany: {
          args: Prisma.CalendarCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CalendarCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>[]
        }
        delete: {
          args: Prisma.CalendarDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        update: {
          args: Prisma.CalendarUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        deleteMany: {
          args: Prisma.CalendarDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CalendarUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CalendarUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>[]
        }
        upsert: {
          args: Prisma.CalendarUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        aggregate: {
          args: Prisma.CalendarAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCalendar>
        }
        groupBy: {
          args: Prisma.CalendarGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CalendarGroupByOutputType>[]
        }
        count: {
          args: Prisma.CalendarCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CalendarCountAggregateOutputType> | number
        }
      }
    }
    Availability: {
      payload: Prisma.$AvailabilityPayload<ExtArgs>
      fields: Prisma.AvailabilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>
        }
        findFirst: {
          args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>
        }
        findMany: {
          args: Prisma.AvailabilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
        }
        create: {
          args: Prisma.AvailabilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>
        }
        createMany: {
          args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AvailabilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
        }
        delete: {
          args: Prisma.AvailabilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>
        }
        update: {
          args: Prisma.AvailabilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>
        }
        deleteMany: {
          args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AvailabilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
        }
        upsert: {
          args: Prisma.AvailabilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AvailabilityPayload>
        }
        aggregate: {
          args: Prisma.AvailabilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAvailability>
        }
        groupBy: {
          args: Prisma.AvailabilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AvailabilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.AvailabilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AvailabilityCountAggregateOutputType> | number
        }
      }
    }
    Appointment: {
      payload: Prisma.$AppointmentPayload<ExtArgs>
      fields: Prisma.AppointmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findFirst: {
          args: Prisma.AppointmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findMany: {
          args: Prisma.AppointmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        create: {
          args: Prisma.AppointmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        createMany: {
          args: Prisma.AppointmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        delete: {
          args: Prisma.AppointmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        update: {
          args: Prisma.AppointmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        deleteMany: {
          args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        upsert: {
          args: Prisma.AppointmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        aggregate: {
          args: Prisma.AppointmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppointment>
        }
        groupBy: {
          args: Prisma.AppointmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.AppointmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentCountAggregateOutputType> | number
        }
      }
    }
    TimeSlot: {
      payload: Prisma.$TimeSlotPayload<ExtArgs>
      fields: Prisma.TimeSlotFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TimeSlotFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TimeSlotFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>
        }
        findFirst: {
          args: Prisma.TimeSlotFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TimeSlotFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>
        }
        findMany: {
          args: Prisma.TimeSlotFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
        }
        create: {
          args: Prisma.TimeSlotCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>
        }
        createMany: {
          args: Prisma.TimeSlotCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TimeSlotCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
        }
        delete: {
          args: Prisma.TimeSlotDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>
        }
        update: {
          args: Prisma.TimeSlotUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>
        }
        deleteMany: {
          args: Prisma.TimeSlotDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TimeSlotUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TimeSlotUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
        }
        upsert: {
          args: Prisma.TimeSlotUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotPayload>
        }
        aggregate: {
          args: Prisma.TimeSlotAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimeSlot>
        }
        groupBy: {
          args: Prisma.TimeSlotGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeSlotGroupByOutputType>[]
        }
        count: {
          args: Prisma.TimeSlotCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeSlotCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    Customer: {
      payload: Prisma.$CustomerPayload<ExtArgs>
      fields: Prisma.CustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findFirst: {
          args: Prisma.CustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findMany: {
          args: Prisma.CustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        create: {
          args: Prisma.CustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        createMany: {
          args: Prisma.CustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        delete: {
          args: Prisma.CustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        update: {
          args: Prisma.CustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        upsert: {
          args: Prisma.CustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        aggregate: {
          args: Prisma.CustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>
        }
        groupBy: {
          args: Prisma.CustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number
        }
      }
    }
    InvoiceItem: {
      payload: Prisma.$InvoiceItemPayload<ExtArgs>
      fields: Prisma.InvoiceItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        findFirst: {
          args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        findMany: {
          args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
        }
        create: {
          args: Prisma.InvoiceItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        createMany: {
          args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
        }
        delete: {
          args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        update: {
          args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        deleteMany: {
          args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
        }
        upsert: {
          args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        aggregate: {
          args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoiceItem>
        }
        groupBy: {
          args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceItemCountAggregateOutputType> | number
        }
      }
    }
    InvoiceTransaction: {
      payload: Prisma.$InvoiceTransactionPayload<ExtArgs>
      fields: Prisma.InvoiceTransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceTransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceTransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>
        }
        findFirst: {
          args: Prisma.InvoiceTransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceTransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>
        }
        findMany: {
          args: Prisma.InvoiceTransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>[]
        }
        create: {
          args: Prisma.InvoiceTransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>
        }
        createMany: {
          args: Prisma.InvoiceTransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceTransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>[]
        }
        delete: {
          args: Prisma.InvoiceTransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>
        }
        update: {
          args: Prisma.InvoiceTransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>
        }
        deleteMany: {
          args: Prisma.InvoiceTransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceTransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceTransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>[]
        }
        upsert: {
          args: Prisma.InvoiceTransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceTransactionPayload>
        }
        aggregate: {
          args: Prisma.InvoiceTransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoiceTransaction>
        }
        groupBy: {
          args: Prisma.InvoiceTransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceTransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceTransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceTransactionCountAggregateOutputType> | number
        }
      }
    }
    Credit: {
      payload: Prisma.$CreditPayload<ExtArgs>
      fields: Prisma.CreditFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CreditFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CreditFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>
        }
        findFirst: {
          args: Prisma.CreditFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CreditFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>
        }
        findMany: {
          args: Prisma.CreditFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>[]
        }
        create: {
          args: Prisma.CreditCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>
        }
        createMany: {
          args: Prisma.CreditCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CreditCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>[]
        }
        delete: {
          args: Prisma.CreditDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>
        }
        update: {
          args: Prisma.CreditUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>
        }
        deleteMany: {
          args: Prisma.CreditDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CreditUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CreditUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>[]
        }
        upsert: {
          args: Prisma.CreditUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditPayload>
        }
        aggregate: {
          args: Prisma.CreditAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCredit>
        }
        groupBy: {
          args: Prisma.CreditGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CreditGroupByOutputType>[]
        }
        count: {
          args: Prisma.CreditCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CreditCountAggregateOutputType> | number
        }
      }
    }
    Refund: {
      payload: Prisma.$RefundPayload<ExtArgs>
      fields: Prisma.RefundFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefundFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        findFirst: {
          args: Prisma.RefundFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        findMany: {
          args: Prisma.RefundFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        create: {
          args: Prisma.RefundCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        createMany: {
          args: Prisma.RefundCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        delete: {
          args: Prisma.RefundDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        update: {
          args: Prisma.RefundUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        deleteMany: {
          args: Prisma.RefundDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefundUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        upsert: {
          args: Prisma.RefundUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        aggregate: {
          args: Prisma.RefundAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefund>
        }
        groupBy: {
          args: Prisma.RefundGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefundCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundCountAggregateOutputType> | number
        }
      }
    }
    ForumCategory: {
      payload: Prisma.$ForumCategoryPayload<ExtArgs>
      fields: Prisma.ForumCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForumCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForumCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
        }
        findFirst: {
          args: Prisma.ForumCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForumCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
        }
        findMany: {
          args: Prisma.ForumCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
        }
        create: {
          args: Prisma.ForumCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
        }
        createMany: {
          args: Prisma.ForumCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForumCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
        }
        delete: {
          args: Prisma.ForumCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
        }
        update: {
          args: Prisma.ForumCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
        }
        deleteMany: {
          args: Prisma.ForumCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForumCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForumCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
        }
        upsert: {
          args: Prisma.ForumCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
        }
        aggregate: {
          args: Prisma.ForumCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForumCategory>
        }
        groupBy: {
          args: Prisma.ForumCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForumCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumCategoryCountAggregateOutputType> | number
        }
      }
    }
    ForumThread: {
      payload: Prisma.$ForumThreadPayload<ExtArgs>
      fields: Prisma.ForumThreadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForumThreadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForumThreadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>
        }
        findFirst: {
          args: Prisma.ForumThreadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForumThreadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>
        }
        findMany: {
          args: Prisma.ForumThreadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>[]
        }
        create: {
          args: Prisma.ForumThreadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>
        }
        createMany: {
          args: Prisma.ForumThreadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForumThreadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>[]
        }
        delete: {
          args: Prisma.ForumThreadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>
        }
        update: {
          args: Prisma.ForumThreadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>
        }
        deleteMany: {
          args: Prisma.ForumThreadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForumThreadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForumThreadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>[]
        }
        upsert: {
          args: Prisma.ForumThreadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumThreadPayload>
        }
        aggregate: {
          args: Prisma.ForumThreadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForumThread>
        }
        groupBy: {
          args: Prisma.ForumThreadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumThreadGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForumThreadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumThreadCountAggregateOutputType> | number
        }
      }
    }
    ForumPost: {
      payload: Prisma.$ForumPostPayload<ExtArgs>
      fields: Prisma.ForumPostFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForumPostFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForumPostFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>
        }
        findFirst: {
          args: Prisma.ForumPostFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForumPostFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>
        }
        findMany: {
          args: Prisma.ForumPostFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
        }
        create: {
          args: Prisma.ForumPostCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>
        }
        createMany: {
          args: Prisma.ForumPostCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForumPostCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
        }
        delete: {
          args: Prisma.ForumPostDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>
        }
        update: {
          args: Prisma.ForumPostUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>
        }
        deleteMany: {
          args: Prisma.ForumPostDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForumPostUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForumPostUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
        }
        upsert: {
          args: Prisma.ForumPostUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForumPostPayload>
        }
        aggregate: {
          args: Prisma.ForumPostAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForumPost>
        }
        groupBy: {
          args: Prisma.ForumPostGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumPostGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForumPostCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForumPostCountAggregateOutputType> | number
        }
      }
    }
    Moderator: {
      payload: Prisma.$ModeratorPayload<ExtArgs>
      fields: Prisma.ModeratorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ModeratorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ModeratorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>
        }
        findFirst: {
          args: Prisma.ModeratorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ModeratorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>
        }
        findMany: {
          args: Prisma.ModeratorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>[]
        }
        create: {
          args: Prisma.ModeratorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>
        }
        createMany: {
          args: Prisma.ModeratorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ModeratorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>[]
        }
        delete: {
          args: Prisma.ModeratorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>
        }
        update: {
          args: Prisma.ModeratorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>
        }
        deleteMany: {
          args: Prisma.ModeratorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ModeratorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ModeratorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>[]
        }
        upsert: {
          args: Prisma.ModeratorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorPayload>
        }
        aggregate: {
          args: Prisma.ModeratorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateModerator>
        }
        groupBy: {
          args: Prisma.ModeratorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ModeratorGroupByOutputType>[]
        }
        count: {
          args: Prisma.ModeratorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ModeratorCountAggregateOutputType> | number
        }
      }
    }
    ModeratorAction: {
      payload: Prisma.$ModeratorActionPayload<ExtArgs>
      fields: Prisma.ModeratorActionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ModeratorActionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ModeratorActionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>
        }
        findFirst: {
          args: Prisma.ModeratorActionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ModeratorActionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>
        }
        findMany: {
          args: Prisma.ModeratorActionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>[]
        }
        create: {
          args: Prisma.ModeratorActionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>
        }
        createMany: {
          args: Prisma.ModeratorActionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ModeratorActionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>[]
        }
        delete: {
          args: Prisma.ModeratorActionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>
        }
        update: {
          args: Prisma.ModeratorActionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>
        }
        deleteMany: {
          args: Prisma.ModeratorActionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ModeratorActionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ModeratorActionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>[]
        }
        upsert: {
          args: Prisma.ModeratorActionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ModeratorActionPayload>
        }
        aggregate: {
          args: Prisma.ModeratorActionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateModeratorAction>
        }
        groupBy: {
          args: Prisma.ModeratorActionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ModeratorActionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ModeratorActionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ModeratorActionCountAggregateOutputType> | number
        }
      }
    }
    Survey: {
      payload: Prisma.$SurveyPayload<ExtArgs>
      fields: Prisma.SurveyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        findFirst: {
          args: Prisma.SurveyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        findMany: {
          args: Prisma.SurveyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        create: {
          args: Prisma.SurveyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        createMany: {
          args: Prisma.SurveyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        delete: {
          args: Prisma.SurveyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        update: {
          args: Prisma.SurveyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        deleteMany: {
          args: Prisma.SurveyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        upsert: {
          args: Prisma.SurveyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        aggregate: {
          args: Prisma.SurveyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurvey>
        }
        groupBy: {
          args: Prisma.SurveyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyCountAggregateOutputType> | number
        }
      }
    }
    SurveyQuestion: {
      payload: Prisma.$SurveyQuestionPayload<ExtArgs>
      fields: Prisma.SurveyQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        findFirst: {
          args: Prisma.SurveyQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        findMany: {
          args: Prisma.SurveyQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        create: {
          args: Prisma.SurveyQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        createMany: {
          args: Prisma.SurveyQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        delete: {
          args: Prisma.SurveyQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        update: {
          args: Prisma.SurveyQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        deleteMany: {
          args: Prisma.SurveyQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        upsert: {
          args: Prisma.SurveyQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        aggregate: {
          args: Prisma.SurveyQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyQuestion>
        }
        groupBy: {
          args: Prisma.SurveyQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionCountAggregateOutputType> | number
        }
      }
    }
    SurveyQuestionOption: {
      payload: Prisma.$SurveyQuestionOptionPayload<ExtArgs>
      fields: Prisma.SurveyQuestionOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyQuestionOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyQuestionOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
        }
        findFirst: {
          args: Prisma.SurveyQuestionOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyQuestionOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
        }
        findMany: {
          args: Prisma.SurveyQuestionOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>[]
        }
        create: {
          args: Prisma.SurveyQuestionOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
        }
        createMany: {
          args: Prisma.SurveyQuestionOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyQuestionOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>[]
        }
        delete: {
          args: Prisma.SurveyQuestionOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
        }
        update: {
          args: Prisma.SurveyQuestionOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
        }
        deleteMany: {
          args: Prisma.SurveyQuestionOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyQuestionOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyQuestionOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>[]
        }
        upsert: {
          args: Prisma.SurveyQuestionOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
        }
        aggregate: {
          args: Prisma.SurveyQuestionOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyQuestionOption>
        }
        groupBy: {
          args: Prisma.SurveyQuestionOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyQuestionOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionOptionCountAggregateOutputType> | number
        }
      }
    }
    SurveyResponse: {
      payload: Prisma.$SurveyResponsePayload<ExtArgs>
      fields: Prisma.SurveyResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        findFirst: {
          args: Prisma.SurveyResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        findMany: {
          args: Prisma.SurveyResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        create: {
          args: Prisma.SurveyResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        createMany: {
          args: Prisma.SurveyResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyResponseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        delete: {
          args: Prisma.SurveyResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        update: {
          args: Prisma.SurveyResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        deleteMany: {
          args: Prisma.SurveyResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyResponseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        upsert: {
          args: Prisma.SurveyResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        aggregate: {
          args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyResponse>
        }
        groupBy: {
          args: Prisma.SurveyResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseCountAggregateOutputType> | number
        }
      }
    }
    SurveyAnswer: {
      payload: Prisma.$SurveyAnswerPayload<ExtArgs>
      fields: Prisma.SurveyAnswerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyAnswerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyAnswerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
        }
        findFirst: {
          args: Prisma.SurveyAnswerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyAnswerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
        }
        findMany: {
          args: Prisma.SurveyAnswerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>[]
        }
        create: {
          args: Prisma.SurveyAnswerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
        }
        createMany: {
          args: Prisma.SurveyAnswerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyAnswerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>[]
        }
        delete: {
          args: Prisma.SurveyAnswerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
        }
        update: {
          args: Prisma.SurveyAnswerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
        }
        deleteMany: {
          args: Prisma.SurveyAnswerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyAnswerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyAnswerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>[]
        }
        upsert: {
          args: Prisma.SurveyAnswerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
        }
        aggregate: {
          args: Prisma.SurveyAnswerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyAnswer>
        }
        groupBy: {
          args: Prisma.SurveyAnswerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyAnswerGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyAnswerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyAnswerCountAggregateOutputType> | number
        }
      }
    }
    Poll: {
      payload: Prisma.$PollPayload<ExtArgs>
      fields: Prisma.PollFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PollFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PollFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>
        }
        findFirst: {
          args: Prisma.PollFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PollFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>
        }
        findMany: {
          args: Prisma.PollFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>[]
        }
        create: {
          args: Prisma.PollCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>
        }
        createMany: {
          args: Prisma.PollCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PollCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>[]
        }
        delete: {
          args: Prisma.PollDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>
        }
        update: {
          args: Prisma.PollUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>
        }
        deleteMany: {
          args: Prisma.PollDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PollUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PollUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>[]
        }
        upsert: {
          args: Prisma.PollUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollPayload>
        }
        aggregate: {
          args: Prisma.PollAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePoll>
        }
        groupBy: {
          args: Prisma.PollGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PollGroupByOutputType>[]
        }
        count: {
          args: Prisma.PollCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PollCountAggregateOutputType> | number
        }
      }
    }
    PollOption: {
      payload: Prisma.$PollOptionPayload<ExtArgs>
      fields: Prisma.PollOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PollOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PollOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>
        }
        findFirst: {
          args: Prisma.PollOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PollOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>
        }
        findMany: {
          args: Prisma.PollOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>[]
        }
        create: {
          args: Prisma.PollOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>
        }
        createMany: {
          args: Prisma.PollOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PollOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>[]
        }
        delete: {
          args: Prisma.PollOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>
        }
        update: {
          args: Prisma.PollOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>
        }
        deleteMany: {
          args: Prisma.PollOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PollOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PollOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>[]
        }
        upsert: {
          args: Prisma.PollOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollOptionPayload>
        }
        aggregate: {
          args: Prisma.PollOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePollOption>
        }
        groupBy: {
          args: Prisma.PollOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PollOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PollOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PollOptionCountAggregateOutputType> | number
        }
      }
    }
    PollVote: {
      payload: Prisma.$PollVotePayload<ExtArgs>
      fields: Prisma.PollVoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PollVoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PollVoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>
        }
        findFirst: {
          args: Prisma.PollVoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PollVoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>
        }
        findMany: {
          args: Prisma.PollVoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>[]
        }
        create: {
          args: Prisma.PollVoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>
        }
        createMany: {
          args: Prisma.PollVoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PollVoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>[]
        }
        delete: {
          args: Prisma.PollVoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>
        }
        update: {
          args: Prisma.PollVoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>
        }
        deleteMany: {
          args: Prisma.PollVoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PollVoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PollVoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>[]
        }
        upsert: {
          args: Prisma.PollVoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PollVotePayload>
        }
        aggregate: {
          args: Prisma.PollVoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePollVote>
        }
        groupBy: {
          args: Prisma.PollVoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PollVoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.PollVoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PollVoteCountAggregateOutputType> | number
        }
      }
    }
    Company: {
      payload: Prisma.$CompanyPayload<ExtArgs>
      fields: Prisma.CompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findFirst: {
          args: Prisma.CompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findMany: {
          args: Prisma.CompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        create: {
          args: Prisma.CompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        createMany: {
          args: Prisma.CompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        delete: {
          args: Prisma.CompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        update: {
          args: Prisma.CompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        deleteMany: {
          args: Prisma.CompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        upsert: {
          args: Prisma.CompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        aggregate: {
          args: Prisma.CompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompany>
        }
        groupBy: {
          args: Prisma.CompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCountAggregateOutputType> | number
        }
      }
    }
    Job: {
      payload: Prisma.$JobPayload<ExtArgs>
      fields: Prisma.JobFieldRefs
      operations: {
        findUnique: {
          args: Prisma.JobFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
        }
        findFirst: {
          args: Prisma.JobFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
        }
        findMany: {
          args: Prisma.JobFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>[]
        }
        create: {
          args: Prisma.JobCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
        }
        createMany: {
          args: Prisma.JobCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>[]
        }
        delete: {
          args: Prisma.JobDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
        }
        update: {
          args: Prisma.JobUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
        }
        deleteMany: {
          args: Prisma.JobDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.JobUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>[]
        }
        upsert: {
          args: Prisma.JobUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
        }
        aggregate: {
          args: Prisma.JobAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJob>
        }
        groupBy: {
          args: Prisma.JobGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JobGroupByOutputType>[]
        }
        count: {
          args: Prisma.JobCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JobCountAggregateOutputType> | number
        }
      }
    }
    JobApplication: {
      payload: Prisma.$JobApplicationPayload<ExtArgs>
      fields: Prisma.JobApplicationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.JobApplicationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.JobApplicationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>
        }
        findFirst: {
          args: Prisma.JobApplicationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.JobApplicationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>
        }
        findMany: {
          args: Prisma.JobApplicationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
        }
        create: {
          args: Prisma.JobApplicationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>
        }
        createMany: {
          args: Prisma.JobApplicationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.JobApplicationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
        }
        delete: {
          args: Prisma.JobApplicationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>
        }
        update: {
          args: Prisma.JobApplicationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>
        }
        deleteMany: {
          args: Prisma.JobApplicationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.JobApplicationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.JobApplicationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
        }
        upsert: {
          args: Prisma.JobApplicationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobApplicationPayload>
        }
        aggregate: {
          args: Prisma.JobApplicationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJobApplication>
        }
        groupBy: {
          args: Prisma.JobApplicationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JobApplicationGroupByOutputType>[]
        }
        count: {
          args: Prisma.JobApplicationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JobApplicationCountAggregateOutputType> | number
        }
      }
    }
    Applicant: {
      payload: Prisma.$ApplicantPayload<ExtArgs>
      fields: Prisma.ApplicantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>
        }
        findFirst: {
          args: Prisma.ApplicantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>
        }
        findMany: {
          args: Prisma.ApplicantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
        }
        create: {
          args: Prisma.ApplicantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>
        }
        createMany: {
          args: Prisma.ApplicantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ApplicantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
        }
        delete: {
          args: Prisma.ApplicantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>
        }
        update: {
          args: Prisma.ApplicantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>
        }
        deleteMany: {
          args: Prisma.ApplicantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ApplicantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
        }
        upsert: {
          args: Prisma.ApplicantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicantPayload>
        }
        aggregate: {
          args: Prisma.ApplicantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicant>
        }
        groupBy: {
          args: Prisma.ApplicantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicantCountAggregateOutputType> | number
        }
      }
    }
    Webhook: {
      payload: Prisma.$WebhookPayload<ExtArgs>
      fields: Prisma.WebhookFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        findFirst: {
          args: Prisma.WebhookFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        findMany: {
          args: Prisma.WebhookFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>[]
        }
        create: {
          args: Prisma.WebhookCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        createMany: {
          args: Prisma.WebhookCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>[]
        }
        delete: {
          args: Prisma.WebhookDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        update: {
          args: Prisma.WebhookUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        deleteMany: {
          args: Prisma.WebhookDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>[]
        }
        upsert: {
          args: Prisma.WebhookUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        aggregate: {
          args: Prisma.WebhookAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhook>
        }
        groupBy: {
          args: Prisma.WebhookGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookCountAggregateOutputType> | number
        }
      }
    }
    WebhookDelivery: {
      payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
      fields: Prisma.WebhookDeliveryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        findFirst: {
          args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        findMany: {
          args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
        }
        create: {
          args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        createMany: {
          args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
        }
        delete: {
          args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        update: {
          args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        deleteMany: {
          args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
        }
        upsert: {
          args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        aggregate: {
          args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhookDelivery>
        }
        groupBy: {
          args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookDeliveryGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookDeliveryCountAggregateOutputType> | number
        }
      }
    }
    APIKey: {
      payload: Prisma.$APIKeyPayload<ExtArgs>
      fields: Prisma.APIKeyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.APIKeyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.APIKeyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>
        }
        findFirst: {
          args: Prisma.APIKeyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.APIKeyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>
        }
        findMany: {
          args: Prisma.APIKeyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>[]
        }
        create: {
          args: Prisma.APIKeyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>
        }
        createMany: {
          args: Prisma.APIKeyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.APIKeyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>[]
        }
        delete: {
          args: Prisma.APIKeyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>
        }
        update: {
          args: Prisma.APIKeyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>
        }
        deleteMany: {
          args: Prisma.APIKeyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.APIKeyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.APIKeyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>[]
        }
        upsert: {
          args: Prisma.APIKeyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>
        }
        aggregate: {
          args: Prisma.APIKeyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAPIKey>
        }
        groupBy: {
          args: Prisma.APIKeyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.APIKeyGroupByOutputType>[]
        }
        count: {
          args: Prisma.APIKeyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.APIKeyCountAggregateOutputType> | number
        }
      }
    }
    APILog: {
      payload: Prisma.$APILogPayload<ExtArgs>
      fields: Prisma.APILogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.APILogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.APILogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>
        }
        findFirst: {
          args: Prisma.APILogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.APILogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>
        }
        findMany: {
          args: Prisma.APILogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>[]
        }
        create: {
          args: Prisma.APILogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>
        }
        createMany: {
          args: Prisma.APILogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.APILogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>[]
        }
        delete: {
          args: Prisma.APILogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>
        }
        update: {
          args: Prisma.APILogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>
        }
        deleteMany: {
          args: Prisma.APILogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.APILogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.APILogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>[]
        }
        upsert: {
          args: Prisma.APILogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APILogPayload>
        }
        aggregate: {
          args: Prisma.APILogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAPILog>
        }
        groupBy: {
          args: Prisma.APILogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.APILogGroupByOutputType>[]
        }
        count: {
          args: Prisma.APILogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.APILogCountAggregateOutputType> | number
        }
      }
    }
    Integration: {
      payload: Prisma.$IntegrationPayload<ExtArgs>
      fields: Prisma.IntegrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        findFirst: {
          args: Prisma.IntegrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        findMany: {
          args: Prisma.IntegrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
        }
        create: {
          args: Prisma.IntegrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        createMany: {
          args: Prisma.IntegrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
        }
        delete: {
          args: Prisma.IntegrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        update: {
          args: Prisma.IntegrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        deleteMany: {
          args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.IntegrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
        }
        upsert: {
          args: Prisma.IntegrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        aggregate: {
          args: Prisma.IntegrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIntegration>
        }
        groupBy: {
          args: Prisma.IntegrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IntegrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.IntegrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IntegrationCountAggregateOutputType> | number
        }
      }
    }
    IntegrationLog: {
      payload: Prisma.$IntegrationLogPayload<ExtArgs>
      fields: Prisma.IntegrationLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IntegrationLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IntegrationLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
        }
        findFirst: {
          args: Prisma.IntegrationLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IntegrationLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
        }
        findMany: {
          args: Prisma.IntegrationLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>[]
        }
        create: {
          args: Prisma.IntegrationLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
        }
        createMany: {
          args: Prisma.IntegrationLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.IntegrationLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>[]
        }
        delete: {
          args: Prisma.IntegrationLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
        }
        update: {
          args: Prisma.IntegrationLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
        }
        deleteMany: {
          args: Prisma.IntegrationLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IntegrationLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.IntegrationLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>[]
        }
        upsert: {
          args: Prisma.IntegrationLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
        }
        aggregate: {
          args: Prisma.IntegrationLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIntegrationLog>
        }
        groupBy: {
          args: Prisma.IntegrationLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IntegrationLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.IntegrationLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IntegrationLogCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const ProfileScalarFieldEnum = {
  id: 'id',
  bio: 'bio',
  avatar: 'avatar',
  website: 'website',
  birthDate: 'birthDate',
  phoneNumber: 'phoneNumber',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


export const AddressScalarFieldEnum = {
  id: 'id',
  street: 'street',
  city: 'city',
  state: 'state',
  country: 'country',
  zipCode: 'zipCode',
  isDefault: 'isDefault',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


export const UserSettingsScalarFieldEnum = {
  id: 'id',
  theme: 'theme',
  language: 'language',
  emailNotifications: 'emailNotifications',
  pushNotifications: 'pushNotifications',
  privacy: 'privacy',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


export const UserSessionScalarFieldEnum = {
  id: 'id',
  token: 'token',
  expiresAt: 'expiresAt',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  userId: 'userId',
  createdAt: 'createdAt'
} as const

export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


export const RoleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const UserRoleScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  roleId: 'roleId',
  assignedAt: 'assignedAt'
} as const

export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


export const PermissionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  resource: 'resource',
  action: 'action',
  createdAt: 'createdAt'
} as const

export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


export const RolePermissionScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  permissionId: 'permissionId',
  grantedAt: 'grantedAt'
} as const

export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


export const PostScalarFieldEnum = {
  id: 'id',
  title: 'title',
  slug: 'slug',
  content: 'content',
  excerpt: 'excerpt',
  published: 'published',
  publishedAt: 'publishedAt',
  featuredImage: 'featuredImage',
  authorId: 'authorId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  content: 'content',
  postId: 'postId',
  authorId: 'authorId',
  parentId: 'parentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const LikeScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  postId: 'postId',
  commentId: 'commentId',
  createdAt: 'createdAt'
} as const

export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


export const TagScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  createdAt: 'createdAt'
} as const

export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


export const PostTagScalarFieldEnum = {
  id: 'id',
  postId: 'postId',
  tagId: 'tagId'
} as const

export type PostTagScalarFieldEnum = (typeof PostTagScalarFieldEnum)[keyof typeof PostTagScalarFieldEnum]


export const CategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  description: 'description',
  parentId: 'parentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


export const PostCategoryScalarFieldEnum = {
  id: 'id',
  postId: 'postId',
  categoryId: 'categoryId'
} as const

export type PostCategoryScalarFieldEnum = (typeof PostCategoryScalarFieldEnum)[keyof typeof PostCategoryScalarFieldEnum]


export const PostRevisionScalarFieldEnum = {
  id: 'id',
  postId: 'postId',
  title: 'title',
  content: 'content',
  authorId: 'authorId',
  createdAt: 'createdAt'
} as const

export type PostRevisionScalarFieldEnum = (typeof PostRevisionScalarFieldEnum)[keyof typeof PostRevisionScalarFieldEnum]


export const PostViewScalarFieldEnum = {
  id: 'id',
  postId: 'postId',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  viewedAt: 'viewedAt'
} as const

export type PostViewScalarFieldEnum = (typeof PostViewScalarFieldEnum)[keyof typeof PostViewScalarFieldEnum]


export const MediaScalarFieldEnum = {
  id: 'id',
  filename: 'filename',
  url: 'url',
  mimeType: 'mimeType',
  size: 'size',
  width: 'width',
  height: 'height',
  uploadedById: 'uploadedById',
  createdAt: 'createdAt'
} as const

export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


export const PostMediaScalarFieldEnum = {
  id: 'id',
  postId: 'postId',
  mediaId: 'mediaId',
  order: 'order'
} as const

export type PostMediaScalarFieldEnum = (typeof PostMediaScalarFieldEnum)[keyof typeof PostMediaScalarFieldEnum]


export const FollowScalarFieldEnum = {
  id: 'id',
  followerId: 'followerId',
  followingId: 'followingId',
  createdAt: 'createdAt'
} as const

export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  message: 'message',
  isRead: 'isRead',
  userId: 'userId',
  createdAt: 'createdAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const ConversationScalarFieldEnum = {
  id: 'id',
  title: 'title',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


export const ConversationParticipantScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  userId: 'userId',
  joinedAt: 'joinedAt'
} as const

export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  content: 'content',
  conversationId: 'conversationId',
  senderId: 'senderId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const ProductScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  description: 'description',
  price: 'price',
  comparePrice: 'comparePrice',
  sku: 'sku',
  stock: 'stock',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


export const ProductCategoryScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  categoryId: 'categoryId'
} as const

export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


export const ProductTagScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  tagId: 'tagId'
} as const

export type ProductTagScalarFieldEnum = (typeof ProductTagScalarFieldEnum)[keyof typeof ProductTagScalarFieldEnum]


export const ProductMediaScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  mediaId: 'mediaId',
  order: 'order',
  isPrimary: 'isPrimary'
} as const

export type ProductMediaScalarFieldEnum = (typeof ProductMediaScalarFieldEnum)[keyof typeof ProductMediaScalarFieldEnum]


export const ProductVariantScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  name: 'name',
  sku: 'sku',
  price: 'price',
  stock: 'stock',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


export const CartScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


export const CartItemScalarFieldEnum = {
  id: 'id',
  cartId: 'cartId',
  productId: 'productId',
  variantId: 'variantId',
  quantity: 'quantity',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


export const OrderScalarFieldEnum = {
  id: 'id',
  orderNumber: 'orderNumber',
  status: 'status',
  subtotal: 'subtotal',
  tax: 'tax',
  shipping: 'shipping',
  total: 'total',
  userId: 'userId',
  addressId: 'addressId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


export const OrderItemScalarFieldEnum = {
  id: 'id',
  orderId: 'orderId',
  productId: 'productId',
  variantId: 'variantId',
  quantity: 'quantity',
  price: 'price',
  total: 'total',
  createdAt: 'createdAt'
} as const

export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


export const PaymentScalarFieldEnum = {
  id: 'id',
  orderId: 'orderId',
  userId: 'userId',
  amount: 'amount',
  currency: 'currency',
  status: 'status',
  paymentMethod: 'paymentMethod',
  transactionId: 'transactionId',
  createdAt: 'createdAt'
} as const

export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


export const ShipmentScalarFieldEnum = {
  id: 'id',
  orderId: 'orderId',
  trackingNumber: 'trackingNumber',
  carrier: 'carrier',
  status: 'status',
  shippedAt: 'shippedAt',
  deliveredAt: 'deliveredAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ShipmentScalarFieldEnum = (typeof ShipmentScalarFieldEnum)[keyof typeof ShipmentScalarFieldEnum]


export const OrganizationScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  description: 'description',
  website: 'website',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


export const OrganizationMemberScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  userId: 'userId',
  role: 'role',
  joinedAt: 'joinedAt'
} as const

export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


export const TeamScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


export const TeamMemberScalarFieldEnum = {
  id: 'id',
  teamId: 'teamId',
  userId: 'userId',
  role: 'role',
  joinedAt: 'joinedAt'
} as const

export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


export const InvitationScalarFieldEnum = {
  id: 'id',
  email: 'email',
  token: 'token',
  invitedById: 'invitedById',
  status: 'status',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


export const ProjectScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  description: 'description',
  status: 'status',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


export const ProjectTeamScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  teamId: 'teamId'
} as const

export type ProjectTeamScalarFieldEnum = (typeof ProjectTeamScalarFieldEnum)[keyof typeof ProjectTeamScalarFieldEnum]


export const TaskScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  status: 'status',
  priority: 'priority',
  dueDate: 'dueDate',
  projectId: 'projectId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


export const ActivityScalarFieldEnum = {
  id: 'id',
  type: 'type',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  metadata: 'metadata',
  userId: 'userId',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  createdAt: 'createdAt'
} as const

export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  oldValue: 'oldValue',
  newValue: 'newValue',
  userId: 'userId',
  ipAddress: 'ipAddress',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const BookmarkScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  postId: 'postId',
  createdAt: 'createdAt'
} as const

export type BookmarkScalarFieldEnum = (typeof BookmarkScalarFieldEnum)[keyof typeof BookmarkScalarFieldEnum]


export const FavoriteScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  itemType: 'itemType',
  itemId: 'itemId',
  createdAt: 'createdAt'
} as const

export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


export const RatingScalarFieldEnum = {
  id: 'id',
  value: 'value',
  userId: 'userId',
  postId: 'postId',
  productId: 'productId',
  createdAt: 'createdAt'
} as const

export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


export const ReviewScalarFieldEnum = {
  id: 'id',
  title: 'title',
  content: 'content',
  rating: 'rating',
  userId: 'userId',
  productId: 'productId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


export const ReportScalarFieldEnum = {
  id: 'id',
  reason: 'reason',
  description: 'description',
  status: 'status',
  reporterId: 'reporterId',
  postId: 'postId',
  commentId: 'commentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


export const FlagScalarFieldEnum = {
  id: 'id',
  type: 'type',
  itemType: 'itemType',
  itemId: 'itemId',
  userId: 'userId',
  createdAt: 'createdAt'
} as const

export type FlagScalarFieldEnum = (typeof FlagScalarFieldEnum)[keyof typeof FlagScalarFieldEnum]


export const SubscriptionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  plan: 'plan',
  status: 'status',
  currentPeriodStart: 'currentPeriodStart',
  currentPeriodEnd: 'currentPeriodEnd',
  cancelAt: 'cancelAt',
  canceledAt: 'canceledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


export const SupportTicketScalarFieldEnum = {
  id: 'id',
  subject: 'subject',
  description: 'description',
  status: 'status',
  priority: 'priority',
  creatorId: 'creatorId',
  assigneeId: 'assigneeId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


export const TicketResponseScalarFieldEnum = {
  id: 'id',
  ticketId: 'ticketId',
  content: 'content',
  isStaff: 'isStaff',
  createdAt: 'createdAt'
} as const

export type TicketResponseScalarFieldEnum = (typeof TicketResponseScalarFieldEnum)[keyof typeof TicketResponseScalarFieldEnum]


export const TicketAttachmentScalarFieldEnum = {
  id: 'id',
  ticketId: 'ticketId',
  filename: 'filename',
  url: 'url',
  size: 'size',
  createdAt: 'createdAt'
} as const

export type TicketAttachmentScalarFieldEnum = (typeof TicketAttachmentScalarFieldEnum)[keyof typeof TicketAttachmentScalarFieldEnum]


export const CourseScalarFieldEnum = {
  id: 'id',
  title: 'title',
  slug: 'slug',
  description: 'description',
  thumbnail: 'thumbnail',
  price: 'price',
  level: 'level',
  status: 'status',
  publishedAt: 'publishedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


export const CourseInstructorScalarFieldEnum = {
  id: 'id',
  courseId: 'courseId',
  instructorId: 'instructorId',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type CourseInstructorScalarFieldEnum = (typeof CourseInstructorScalarFieldEnum)[keyof typeof CourseInstructorScalarFieldEnum]


export const InstructorScalarFieldEnum = {
  id: 'id',
  name: 'name',
  bio: 'bio',
  avatar: 'avatar',
  title: 'title',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InstructorScalarFieldEnum = (typeof InstructorScalarFieldEnum)[keyof typeof InstructorScalarFieldEnum]


export const CourseCategoryScalarFieldEnum = {
  id: 'id',
  courseId: 'courseId',
  categoryId: 'categoryId'
} as const

export type CourseCategoryScalarFieldEnum = (typeof CourseCategoryScalarFieldEnum)[keyof typeof CourseCategoryScalarFieldEnum]


export const CourseModuleScalarFieldEnum = {
  id: 'id',
  courseId: 'courseId',
  title: 'title',
  description: 'description',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CourseModuleScalarFieldEnum = (typeof CourseModuleScalarFieldEnum)[keyof typeof CourseModuleScalarFieldEnum]


export const LessonScalarFieldEnum = {
  id: 'id',
  moduleId: 'moduleId',
  title: 'title',
  content: 'content',
  videoUrl: 'videoUrl',
  duration: 'duration',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


export const EnrollmentScalarFieldEnum = {
  id: 'id',
  courseId: 'courseId',
  studentId: 'studentId',
  status: 'status',
  progress: 'progress',
  completedAt: 'completedAt',
  enrolledAt: 'enrolledAt'
} as const

export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


export const StudentScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


export const LessonProgressScalarFieldEnum = {
  id: 'id',
  lessonId: 'lessonId',
  studentId: 'studentId',
  completed: 'completed',
  watchTime: 'watchTime',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LessonProgressScalarFieldEnum = (typeof LessonProgressScalarFieldEnum)[keyof typeof LessonProgressScalarFieldEnum]


export const AssignmentScalarFieldEnum = {
  id: 'id',
  lessonId: 'lessonId',
  title: 'title',
  description: 'description',
  dueDate: 'dueDate',
  maxScore: 'maxScore',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


export const AssignmentSubmissionScalarFieldEnum = {
  id: 'id',
  assignmentId: 'assignmentId',
  studentId: 'studentId',
  content: 'content',
  attachments: 'attachments',
  score: 'score',
  feedback: 'feedback',
  submittedAt: 'submittedAt',
  gradedAt: 'gradedAt'
} as const

export type AssignmentSubmissionScalarFieldEnum = (typeof AssignmentSubmissionScalarFieldEnum)[keyof typeof AssignmentSubmissionScalarFieldEnum]


export const QuizScalarFieldEnum = {
  id: 'id',
  lessonId: 'lessonId',
  title: 'title',
  description: 'description',
  timeLimit: 'timeLimit',
  passingScore: 'passingScore',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


export const QuizQuestionScalarFieldEnum = {
  id: 'id',
  quizId: 'quizId',
  question: 'question',
  type: 'type',
  points: 'points',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


export const QuizOptionScalarFieldEnum = {
  id: 'id',
  questionId: 'questionId',
  text: 'text',
  isCorrect: 'isCorrect',
  order: 'order'
} as const

export type QuizOptionScalarFieldEnum = (typeof QuizOptionScalarFieldEnum)[keyof typeof QuizOptionScalarFieldEnum]


export const QuizAttemptScalarFieldEnum = {
  id: 'id',
  quizId: 'quizId',
  studentId: 'studentId',
  score: 'score',
  passed: 'passed',
  startedAt: 'startedAt',
  completedAt: 'completedAt'
} as const

export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


export const QuizAnswerScalarFieldEnum = {
  id: 'id',
  attemptId: 'attemptId',
  questionId: 'questionId',
  answer: 'answer',
  isCorrect: 'isCorrect',
  createdAt: 'createdAt'
} as const

export type QuizAnswerScalarFieldEnum = (typeof QuizAnswerScalarFieldEnum)[keyof typeof QuizAnswerScalarFieldEnum]


export const CertificateScalarFieldEnum = {
  id: 'id',
  courseId: 'courseId',
  studentId: 'studentId',
  code: 'code',
  issuedAt: 'issuedAt',
  expiresAt: 'expiresAt'
} as const

export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


export const CourseReviewScalarFieldEnum = {
  id: 'id',
  courseId: 'courseId',
  rating: 'rating',
  title: 'title',
  content: 'content',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CourseReviewScalarFieldEnum = (typeof CourseReviewScalarFieldEnum)[keyof typeof CourseReviewScalarFieldEnum]


export const EventScalarFieldEnum = {
  id: 'id',
  title: 'title',
  slug: 'slug',
  description: 'description',
  thumbnail: 'thumbnail',
  startDate: 'startDate',
  endDate: 'endDate',
  timezone: 'timezone',
  location: 'location',
  type: 'type',
  capacity: 'capacity',
  status: 'status',
  venueId: 'venueId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


export const VenueScalarFieldEnum = {
  id: 'id',
  name: 'name',
  address: 'address',
  city: 'city',
  state: 'state',
  country: 'country',
  zipCode: 'zipCode',
  capacity: 'capacity',
  amenities: 'amenities',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


export const EventTicketScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  name: 'name',
  description: 'description',
  price: 'price',
  quantity: 'quantity',
  sold: 'sold',
  salesStart: 'salesStart',
  salesEnd: 'salesEnd',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventTicketScalarFieldEnum = (typeof EventTicketScalarFieldEnum)[keyof typeof EventTicketScalarFieldEnum]


export const EventRegistrationScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  ticketId: 'ticketId',
  attendeeId: 'attendeeId',
  status: 'status',
  checkedIn: 'checkedIn',
  checkedInAt: 'checkedInAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


export const AttendeeScalarFieldEnum = {
  id: 'id',
  firstName: 'firstName',
  lastName: 'lastName',
  email: 'email',
  phone: 'phone',
  company: 'company',
  jobTitle: 'jobTitle',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AttendeeScalarFieldEnum = (typeof AttendeeScalarFieldEnum)[keyof typeof AttendeeScalarFieldEnum]


export const EventSessionScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  title: 'title',
  description: 'description',
  startTime: 'startTime',
  endTime: 'endTime',
  location: 'location',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventSessionScalarFieldEnum = (typeof EventSessionScalarFieldEnum)[keyof typeof EventSessionScalarFieldEnum]


export const SpeakerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  bio: 'bio',
  photo: 'photo',
  title: 'title',
  company: 'company',
  email: 'email',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SpeakerScalarFieldEnum = (typeof SpeakerScalarFieldEnum)[keyof typeof SpeakerScalarFieldEnum]


export const EventSpeakerScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  speakerId: 'speakerId',
  featured: 'featured'
} as const

export type EventSpeakerScalarFieldEnum = (typeof EventSpeakerScalarFieldEnum)[keyof typeof EventSpeakerScalarFieldEnum]


export const SessionSpeakerScalarFieldEnum = {
  id: 'id',
  sessionId: 'sessionId',
  speakerId: 'speakerId'
} as const

export type SessionSpeakerScalarFieldEnum = (typeof SessionSpeakerScalarFieldEnum)[keyof typeof SessionSpeakerScalarFieldEnum]


export const SponsorScalarFieldEnum = {
  id: 'id',
  name: 'name',
  logo: 'logo',
  website: 'website',
  tier: 'tier',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SponsorScalarFieldEnum = (typeof SponsorScalarFieldEnum)[keyof typeof SponsorScalarFieldEnum]


export const EventSponsorScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  sponsorId: 'sponsorId',
  tier: 'tier',
  amount: 'amount'
} as const

export type EventSponsorScalarFieldEnum = (typeof EventSponsorScalarFieldEnum)[keyof typeof EventSponsorScalarFieldEnum]


export const FolderScalarFieldEnum = {
  id: 'id',
  name: 'name',
  parentId: 'parentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


export const FileScalarFieldEnum = {
  id: 'id',
  name: 'name',
  filename: 'filename',
  path: 'path',
  mimeType: 'mimeType',
  size: 'size',
  checksum: 'checksum',
  folderId: 'folderId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


export const FileVersionScalarFieldEnum = {
  id: 'id',
  fileId: 'fileId',
  version: 'version',
  filename: 'filename',
  path: 'path',
  size: 'size',
  checksum: 'checksum',
  createdAt: 'createdAt'
} as const

export type FileVersionScalarFieldEnum = (typeof FileVersionScalarFieldEnum)[keyof typeof FileVersionScalarFieldEnum]


export const FileShareScalarFieldEnum = {
  id: 'id',
  fileId: 'fileId',
  token: 'token',
  password: 'password',
  expiresAt: 'expiresAt',
  maxDownloads: 'maxDownloads',
  downloads: 'downloads',
  createdAt: 'createdAt'
} as const

export type FileShareScalarFieldEnum = (typeof FileShareScalarFieldEnum)[keyof typeof FileShareScalarFieldEnum]


export const FolderShareScalarFieldEnum = {
  id: 'id',
  folderId: 'folderId',
  token: 'token',
  password: 'password',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type FolderShareScalarFieldEnum = (typeof FolderShareScalarFieldEnum)[keyof typeof FolderShareScalarFieldEnum]


export const FilePermissionScalarFieldEnum = {
  id: 'id',
  fileId: 'fileId',
  userEmail: 'userEmail',
  permission: 'permission',
  createdAt: 'createdAt'
} as const

export type FilePermissionScalarFieldEnum = (typeof FilePermissionScalarFieldEnum)[keyof typeof FilePermissionScalarFieldEnum]


export const FileDownloadScalarFieldEnum = {
  id: 'id',
  fileId: 'fileId',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  downloadedAt: 'downloadedAt'
} as const

export type FileDownloadScalarFieldEnum = (typeof FileDownloadScalarFieldEnum)[keyof typeof FileDownloadScalarFieldEnum]


export const PageViewScalarFieldEnum = {
  id: 'id',
  path: 'path',
  title: 'title',
  referrer: 'referrer',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  sessionId: 'sessionId',
  duration: 'duration',
  viewedAt: 'viewedAt'
} as const

export type PageViewScalarFieldEnum = (typeof PageViewScalarFieldEnum)[keyof typeof PageViewScalarFieldEnum]


export const AnalyticsSessionScalarFieldEnum = {
  id: 'id',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  country: 'country',
  city: 'city',
  device: 'device',
  browser: 'browser',
  os: 'os',
  startedAt: 'startedAt',
  endedAt: 'endedAt'
} as const

export type AnalyticsSessionScalarFieldEnum = (typeof AnalyticsSessionScalarFieldEnum)[keyof typeof AnalyticsSessionScalarFieldEnum]


export const AnalyticsEventScalarFieldEnum = {
  id: 'id',
  name: 'name',
  category: 'category',
  action: 'action',
  label: 'label',
  value: 'value',
  metadata: 'metadata',
  sessionId: 'sessionId',
  createdAt: 'createdAt'
} as const

export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


export const ConversionGoalScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  value: 'value',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConversionGoalScalarFieldEnum = (typeof ConversionGoalScalarFieldEnum)[keyof typeof ConversionGoalScalarFieldEnum]


export const ConversionScalarFieldEnum = {
  id: 'id',
  goalId: 'goalId',
  sessionId: 'sessionId',
  value: 'value',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type ConversionScalarFieldEnum = (typeof ConversionScalarFieldEnum)[keyof typeof ConversionScalarFieldEnum]


export const ABTestScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ABTestScalarFieldEnum = (typeof ABTestScalarFieldEnum)[keyof typeof ABTestScalarFieldEnum]


export const ABTestVariantScalarFieldEnum = {
  id: 'id',
  testId: 'testId',
  name: 'name',
  allocation: 'allocation',
  conversions: 'conversions',
  views: 'views',
  createdAt: 'createdAt'
} as const

export type ABTestVariantScalarFieldEnum = (typeof ABTestVariantScalarFieldEnum)[keyof typeof ABTestVariantScalarFieldEnum]


export const ABTestAssignmentScalarFieldEnum = {
  id: 'id',
  testId: 'testId',
  variantId: 'variantId',
  sessionId: 'sessionId',
  assignedAt: 'assignedAt'
} as const

export type ABTestAssignmentScalarFieldEnum = (typeof ABTestAssignmentScalarFieldEnum)[keyof typeof ABTestAssignmentScalarFieldEnum]


export const CampaignScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  budget: 'budget',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


export const CampaignEmailScalarFieldEnum = {
  id: 'id',
  campaignId: 'campaignId',
  subject: 'subject',
  content: 'content',
  scheduledAt: 'scheduledAt',
  sentAt: 'sentAt',
  opens: 'opens',
  clicks: 'clicks',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampaignEmailScalarFieldEnum = (typeof CampaignEmailScalarFieldEnum)[keyof typeof CampaignEmailScalarFieldEnum]


export const EmailRecipientScalarFieldEnum = {
  id: 'id',
  emailId: 'emailId',
  address: 'address',
  status: 'status',
  sentAt: 'sentAt',
  openedAt: 'openedAt',
  clickedAt: 'clickedAt',
  bouncedAt: 'bouncedAt',
  createdAt: 'createdAt'
} as const

export type EmailRecipientScalarFieldEnum = (typeof EmailRecipientScalarFieldEnum)[keyof typeof EmailRecipientScalarFieldEnum]


export const SegmentScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  rules: 'rules',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SegmentScalarFieldEnum = (typeof SegmentScalarFieldEnum)[keyof typeof SegmentScalarFieldEnum]


export const CampaignSegmentScalarFieldEnum = {
  id: 'id',
  campaignId: 'campaignId',
  segmentId: 'segmentId'
} as const

export type CampaignSegmentScalarFieldEnum = (typeof CampaignSegmentScalarFieldEnum)[keyof typeof CampaignSegmentScalarFieldEnum]


export const SegmentSubscriberScalarFieldEnum = {
  id: 'id',
  segmentId: 'segmentId',
  subscriberId: 'subscriberId',
  addedAt: 'addedAt'
} as const

export type SegmentSubscriberScalarFieldEnum = (typeof SegmentSubscriberScalarFieldEnum)[keyof typeof SegmentSubscriberScalarFieldEnum]


export const SubscriberScalarFieldEnum = {
  id: 'id',
  email: 'email',
  firstName: 'firstName',
  lastName: 'lastName',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SubscriberScalarFieldEnum = (typeof SubscriberScalarFieldEnum)[keyof typeof SubscriberScalarFieldEnum]


export const NewsletterScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  frequency: 'frequency',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsletterScalarFieldEnum = (typeof NewsletterScalarFieldEnum)[keyof typeof NewsletterScalarFieldEnum]


export const NewsletterSubscriberScalarFieldEnum = {
  id: 'id',
  newsletterId: 'newsletterId',
  subscriberId: 'subscriberId',
  subscribedAt: 'subscribedAt'
} as const

export type NewsletterSubscriberScalarFieldEnum = (typeof NewsletterSubscriberScalarFieldEnum)[keyof typeof NewsletterSubscriberScalarFieldEnum]


export const NewsletterIssueScalarFieldEnum = {
  id: 'id',
  newsletterId: 'newsletterId',
  subject: 'subject',
  content: 'content',
  status: 'status',
  scheduledAt: 'scheduledAt',
  sentAt: 'sentAt',
  opens: 'opens',
  clicks: 'clicks',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsletterIssueScalarFieldEnum = (typeof NewsletterIssueScalarFieldEnum)[keyof typeof NewsletterIssueScalarFieldEnum]


export const LandingPageScalarFieldEnum = {
  id: 'id',
  title: 'title',
  slug: 'slug',
  content: 'content',
  template: 'template',
  published: 'published',
  publishedAt: 'publishedAt',
  views: 'views',
  conversions: 'conversions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LandingPageScalarFieldEnum = (typeof LandingPageScalarFieldEnum)[keyof typeof LandingPageScalarFieldEnum]


export const CalendarScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  timezone: 'timezone',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


export const AvailabilityScalarFieldEnum = {
  id: 'id',
  calendarId: 'calendarId',
  dayOfWeek: 'dayOfWeek',
  startTime: 'startTime',
  endTime: 'endTime',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


export const AppointmentScalarFieldEnum = {
  id: 'id',
  calendarId: 'calendarId',
  title: 'title',
  description: 'description',
  startTime: 'startTime',
  endTime: 'endTime',
  status: 'status',
  attendeeEmail: 'attendeeEmail',
  attendeeName: 'attendeeName',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


export const TimeSlotScalarFieldEnum = {
  id: 'id',
  date: 'date',
  startTime: 'startTime',
  endTime: 'endTime',
  available: 'available',
  capacity: 'capacity',
  booked: 'booked',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TimeSlotScalarFieldEnum = (typeof TimeSlotScalarFieldEnum)[keyof typeof TimeSlotScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  number: 'number',
  customerId: 'customerId',
  status: 'status',
  subtotal: 'subtotal',
  tax: 'tax',
  total: 'total',
  currency: 'currency',
  dueDate: 'dueDate',
  paidAt: 'paidAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const CustomerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  company: 'company',
  taxId: 'taxId',
  billingAddress: 'billingAddress',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


export const InvoiceItemScalarFieldEnum = {
  id: 'id',
  invoiceId: 'invoiceId',
  description: 'description',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  total: 'total',
  taxRate: 'taxRate'
} as const

export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


export const InvoiceTransactionScalarFieldEnum = {
  id: 'id',
  invoiceId: 'invoiceId',
  amount: 'amount',
  method: 'method',
  reference: 'reference',
  status: 'status',
  processedAt: 'processedAt',
  createdAt: 'createdAt'
} as const

export type InvoiceTransactionScalarFieldEnum = (typeof InvoiceTransactionScalarFieldEnum)[keyof typeof InvoiceTransactionScalarFieldEnum]


export const CreditScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  amount: 'amount',
  balance: 'balance',
  reason: 'reason',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type CreditScalarFieldEnum = (typeof CreditScalarFieldEnum)[keyof typeof CreditScalarFieldEnum]


export const RefundScalarFieldEnum = {
  id: 'id',
  reference: 'reference',
  amount: 'amount',
  reason: 'reason',
  status: 'status',
  processedAt: 'processedAt',
  createdAt: 'createdAt'
} as const

export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


export const ForumCategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  description: 'description',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForumCategoryScalarFieldEnum = (typeof ForumCategoryScalarFieldEnum)[keyof typeof ForumCategoryScalarFieldEnum]


export const ForumThreadScalarFieldEnum = {
  id: 'id',
  title: 'title',
  slug: 'slug',
  categoryId: 'categoryId',
  isPinned: 'isPinned',
  isLocked: 'isLocked',
  views: 'views',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForumThreadScalarFieldEnum = (typeof ForumThreadScalarFieldEnum)[keyof typeof ForumThreadScalarFieldEnum]


export const ForumPostScalarFieldEnum = {
  id: 'id',
  threadId: 'threadId',
  content: 'content',
  authorName: 'authorName',
  authorEmail: 'authorEmail',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForumPostScalarFieldEnum = (typeof ForumPostScalarFieldEnum)[keyof typeof ForumPostScalarFieldEnum]


export const ModeratorScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type ModeratorScalarFieldEnum = (typeof ModeratorScalarFieldEnum)[keyof typeof ModeratorScalarFieldEnum]


export const ModeratorActionScalarFieldEnum = {
  id: 'id',
  moderatorId: 'moderatorId',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  reason: 'reason',
  createdAt: 'createdAt'
} as const

export type ModeratorActionScalarFieldEnum = (typeof ModeratorActionScalarFieldEnum)[keyof typeof ModeratorActionScalarFieldEnum]


export const SurveyScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


export const SurveyQuestionScalarFieldEnum = {
  id: 'id',
  surveyId: 'surveyId',
  question: 'question',
  type: 'type',
  required: 'required',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SurveyQuestionScalarFieldEnum = (typeof SurveyQuestionScalarFieldEnum)[keyof typeof SurveyQuestionScalarFieldEnum]


export const SurveyQuestionOptionScalarFieldEnum = {
  id: 'id',
  questionId: 'questionId',
  text: 'text',
  order: 'order'
} as const

export type SurveyQuestionOptionScalarFieldEnum = (typeof SurveyQuestionOptionScalarFieldEnum)[keyof typeof SurveyQuestionOptionScalarFieldEnum]


export const SurveyResponseScalarFieldEnum = {
  id: 'id',
  surveyId: 'surveyId',
  respondentEmail: 'respondentEmail',
  respondentName: 'respondentName',
  submittedAt: 'submittedAt'
} as const

export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


export const SurveyAnswerScalarFieldEnum = {
  id: 'id',
  responseId: 'responseId',
  questionId: 'questionId',
  answer: 'answer',
  createdAt: 'createdAt'
} as const

export type SurveyAnswerScalarFieldEnum = (typeof SurveyAnswerScalarFieldEnum)[keyof typeof SurveyAnswerScalarFieldEnum]


export const PollScalarFieldEnum = {
  id: 'id',
  question: 'question',
  description: 'description',
  status: 'status',
  allowMultiple: 'allowMultiple',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PollScalarFieldEnum = (typeof PollScalarFieldEnum)[keyof typeof PollScalarFieldEnum]


export const PollOptionScalarFieldEnum = {
  id: 'id',
  pollId: 'pollId',
  text: 'text',
  order: 'order',
  createdAt: 'createdAt'
} as const

export type PollOptionScalarFieldEnum = (typeof PollOptionScalarFieldEnum)[keyof typeof PollOptionScalarFieldEnum]


export const PollVoteScalarFieldEnum = {
  id: 'id',
  pollId: 'pollId',
  optionId: 'optionId',
  ipAddress: 'ipAddress',
  votedAt: 'votedAt'
} as const

export type PollVoteScalarFieldEnum = (typeof PollVoteScalarFieldEnum)[keyof typeof PollVoteScalarFieldEnum]


export const CompanyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  logo: 'logo',
  website: 'website',
  description: 'description',
  size: 'size',
  industry: 'industry',
  location: 'location',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


export const JobScalarFieldEnum = {
  id: 'id',
  title: 'title',
  slug: 'slug',
  description: 'description',
  requirements: 'requirements',
  benefits: 'benefits',
  type: 'type',
  location: 'location',
  remote: 'remote',
  salary: 'salary',
  status: 'status',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


export const JobApplicationScalarFieldEnum = {
  id: 'id',
  jobId: 'jobId',
  applicantId: 'applicantId',
  status: 'status',
  coverLetter: 'coverLetter',
  resume: 'resume',
  submittedAt: 'submittedAt',
  reviewedAt: 'reviewedAt'
} as const

export type JobApplicationScalarFieldEnum = (typeof JobApplicationScalarFieldEnum)[keyof typeof JobApplicationScalarFieldEnum]


export const ApplicantScalarFieldEnum = {
  id: 'id',
  firstName: 'firstName',
  lastName: 'lastName',
  email: 'email',
  phone: 'phone',
  location: 'location',
  portfolio: 'portfolio',
  linkedIn: 'linkedIn',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApplicantScalarFieldEnum = (typeof ApplicantScalarFieldEnum)[keyof typeof ApplicantScalarFieldEnum]


export const WebhookScalarFieldEnum = {
  id: 'id',
  url: 'url',
  events: 'events',
  secret: 'secret',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


export const WebhookDeliveryScalarFieldEnum = {
  id: 'id',
  webhookId: 'webhookId',
  event: 'event',
  payload: 'payload',
  status: 'status',
  attempts: 'attempts',
  response: 'response',
  deliveredAt: 'deliveredAt',
  createdAt: 'createdAt'
} as const

export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


export const APIKeyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  key: 'key',
  permissions: 'permissions',
  lastUsedAt: 'lastUsedAt',
  expiresAt: 'expiresAt',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type APIKeyScalarFieldEnum = (typeof APIKeyScalarFieldEnum)[keyof typeof APIKeyScalarFieldEnum]


export const APILogScalarFieldEnum = {
  id: 'id',
  apiKeyId: 'apiKeyId',
  endpoint: 'endpoint',
  method: 'method',
  statusCode: 'statusCode',
  duration: 'duration',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  createdAt: 'createdAt'
} as const

export type APILogScalarFieldEnum = (typeof APILogScalarFieldEnum)[keyof typeof APILogScalarFieldEnum]


export const IntegrationScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  config: 'config',
  isActive: 'isActive',
  lastSyncAt: 'lastSyncAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


export const IntegrationLogScalarFieldEnum = {
  id: 'id',
  integrationId: 'integrationId',
  action: 'action',
  status: 'status',
  message: 'message',
  data: 'data',
  createdAt: 'createdAt'
} as const

export type IntegrationLogScalarFieldEnum = (typeof IntegrationLogScalarFieldEnum)[keyof typeof IntegrationLogScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  profile?: Prisma.ProfileOmit
  address?: Prisma.AddressOmit
  userSettings?: Prisma.UserSettingsOmit
  userSession?: Prisma.UserSessionOmit
  role?: Prisma.RoleOmit
  userRole?: Prisma.UserRoleOmit
  permission?: Prisma.PermissionOmit
  rolePermission?: Prisma.RolePermissionOmit
  post?: Prisma.PostOmit
  comment?: Prisma.CommentOmit
  like?: Prisma.LikeOmit
  tag?: Prisma.TagOmit
  postTag?: Prisma.PostTagOmit
  category?: Prisma.CategoryOmit
  postCategory?: Prisma.PostCategoryOmit
  postRevision?: Prisma.PostRevisionOmit
  postView?: Prisma.PostViewOmit
  media?: Prisma.MediaOmit
  postMedia?: Prisma.PostMediaOmit
  follow?: Prisma.FollowOmit
  notification?: Prisma.NotificationOmit
  conversation?: Prisma.ConversationOmit
  conversationParticipant?: Prisma.ConversationParticipantOmit
  message?: Prisma.MessageOmit
  product?: Prisma.ProductOmit
  productCategory?: Prisma.ProductCategoryOmit
  productTag?: Prisma.ProductTagOmit
  productMedia?: Prisma.ProductMediaOmit
  productVariant?: Prisma.ProductVariantOmit
  cart?: Prisma.CartOmit
  cartItem?: Prisma.CartItemOmit
  order?: Prisma.OrderOmit
  orderItem?: Prisma.OrderItemOmit
  payment?: Prisma.PaymentOmit
  shipment?: Prisma.ShipmentOmit
  organization?: Prisma.OrganizationOmit
  organizationMember?: Prisma.OrganizationMemberOmit
  team?: Prisma.TeamOmit
  teamMember?: Prisma.TeamMemberOmit
  invitation?: Prisma.InvitationOmit
  project?: Prisma.ProjectOmit
  projectTeam?: Prisma.ProjectTeamOmit
  task?: Prisma.TaskOmit
  activity?: Prisma.ActivityOmit
  auditLog?: Prisma.AuditLogOmit
  bookmark?: Prisma.BookmarkOmit
  favorite?: Prisma.FavoriteOmit
  rating?: Prisma.RatingOmit
  review?: Prisma.ReviewOmit
  report?: Prisma.ReportOmit
  flag?: Prisma.FlagOmit
  subscription?: Prisma.SubscriptionOmit
  supportTicket?: Prisma.SupportTicketOmit
  ticketResponse?: Prisma.TicketResponseOmit
  ticketAttachment?: Prisma.TicketAttachmentOmit
  course?: Prisma.CourseOmit
  courseInstructor?: Prisma.CourseInstructorOmit
  instructor?: Prisma.InstructorOmit
  courseCategory?: Prisma.CourseCategoryOmit
  courseModule?: Prisma.CourseModuleOmit
  lesson?: Prisma.LessonOmit
  enrollment?: Prisma.EnrollmentOmit
  student?: Prisma.StudentOmit
  lessonProgress?: Prisma.LessonProgressOmit
  assignment?: Prisma.AssignmentOmit
  assignmentSubmission?: Prisma.AssignmentSubmissionOmit
  quiz?: Prisma.QuizOmit
  quizQuestion?: Prisma.QuizQuestionOmit
  quizOption?: Prisma.QuizOptionOmit
  quizAttempt?: Prisma.QuizAttemptOmit
  quizAnswer?: Prisma.QuizAnswerOmit
  certificate?: Prisma.CertificateOmit
  courseReview?: Prisma.CourseReviewOmit
  event?: Prisma.EventOmit
  venue?: Prisma.VenueOmit
  eventTicket?: Prisma.EventTicketOmit
  eventRegistration?: Prisma.EventRegistrationOmit
  attendee?: Prisma.AttendeeOmit
  eventSession?: Prisma.EventSessionOmit
  speaker?: Prisma.SpeakerOmit
  eventSpeaker?: Prisma.EventSpeakerOmit
  sessionSpeaker?: Prisma.SessionSpeakerOmit
  sponsor?: Prisma.SponsorOmit
  eventSponsor?: Prisma.EventSponsorOmit
  folder?: Prisma.FolderOmit
  file?: Prisma.FileOmit
  fileVersion?: Prisma.FileVersionOmit
  fileShare?: Prisma.FileShareOmit
  folderShare?: Prisma.FolderShareOmit
  filePermission?: Prisma.FilePermissionOmit
  fileDownload?: Prisma.FileDownloadOmit
  pageView?: Prisma.PageViewOmit
  analyticsSession?: Prisma.AnalyticsSessionOmit
  analyticsEvent?: Prisma.AnalyticsEventOmit
  conversionGoal?: Prisma.ConversionGoalOmit
  conversion?: Prisma.ConversionOmit
  aBTest?: Prisma.ABTestOmit
  aBTestVariant?: Prisma.ABTestVariantOmit
  aBTestAssignment?: Prisma.ABTestAssignmentOmit
  campaign?: Prisma.CampaignOmit
  campaignEmail?: Prisma.CampaignEmailOmit
  emailRecipient?: Prisma.EmailRecipientOmit
  segment?: Prisma.SegmentOmit
  campaignSegment?: Prisma.CampaignSegmentOmit
  segmentSubscriber?: Prisma.SegmentSubscriberOmit
  subscriber?: Prisma.SubscriberOmit
  newsletter?: Prisma.NewsletterOmit
  newsletterSubscriber?: Prisma.NewsletterSubscriberOmit
  newsletterIssue?: Prisma.NewsletterIssueOmit
  landingPage?: Prisma.LandingPageOmit
  calendar?: Prisma.CalendarOmit
  availability?: Prisma.AvailabilityOmit
  appointment?: Prisma.AppointmentOmit
  timeSlot?: Prisma.TimeSlotOmit
  invoice?: Prisma.InvoiceOmit
  customer?: Prisma.CustomerOmit
  invoiceItem?: Prisma.InvoiceItemOmit
  invoiceTransaction?: Prisma.InvoiceTransactionOmit
  credit?: Prisma.CreditOmit
  refund?: Prisma.RefundOmit
  forumCategory?: Prisma.ForumCategoryOmit
  forumThread?: Prisma.ForumThreadOmit
  forumPost?: Prisma.ForumPostOmit
  moderator?: Prisma.ModeratorOmit
  moderatorAction?: Prisma.ModeratorActionOmit
  survey?: Prisma.SurveyOmit
  surveyQuestion?: Prisma.SurveyQuestionOmit
  surveyQuestionOption?: Prisma.SurveyQuestionOptionOmit
  surveyResponse?: Prisma.SurveyResponseOmit
  surveyAnswer?: Prisma.SurveyAnswerOmit
  poll?: Prisma.PollOmit
  pollOption?: Prisma.PollOptionOmit
  pollVote?: Prisma.PollVoteOmit
  company?: Prisma.CompanyOmit
  job?: Prisma.JobOmit
  jobApplication?: Prisma.JobApplicationOmit
  applicant?: Prisma.ApplicantOmit
  webhook?: Prisma.WebhookOmit
  webhookDelivery?: Prisma.WebhookDeliveryOmit
  aPIKey?: Prisma.APIKeyOmit
  aPILog?: Prisma.APILogOmit
  integration?: Prisma.IntegrationOmit
  integrationLog?: Prisma.IntegrationLogOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

